# file: .github/workflows/pr-automation.yml
# version: 4.5.1
# guid: a7b8c9d0-e1f2-3456-a789-0123456789bc
# NOTE: This file should be updated in ghcommon repository first, then copied to other repositories.
# To update: Edit in https://github.com/jdfalk/ghcommon/.github/workflows/pr-automation.yml then copy to other repos

# âš ï¸  DO NOT EDIT DIRECTLY - This file is managed in ghcommon repository
# All changes should be made in jdfalk/ghcommon and will be synced to other repositories
# Edit this file at: https://github.com/jdfalk/ghcommon/edit/main/.github/workflows/pr-automation.yml

name: PR Automation

on:
  pull_request:
    types: [opened, edited, synchronize, reopened, labeled, unlabeled]
  pull_request_target:
    types: [opened, edited, synchronize, reopened]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: write
  statuses: write
  security-events: write
  actions: write
  packages: read
  id-token: write
  repository-projects: write

env:
  VALIDATE_ALL_CODEBASE: false
  DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
  FILTER_REGEX_EXCLUDE: ".*\\.git/.*|.*\\.github/copilot/.*|.*\\.vscode/.*|.*node_modules/.*|.*\\.cache/.*|.*vendor/.*|.*dist/.*"

jobs:
  # Primary code quality check - runs on all PRs
  code-quality:
    name: Code Quality Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.13"

      - name: Detect project languages (for linter toolchain setup)
        id: detect_langs
        run: |
          go_present=false
          if [ -f "go.mod" ]; then
            go_present=true
          fi

          rust_present=false
          if [ -f "Cargo.toml" ]; then
            rust_present=true
          fi

          node_present=false
          if [ -f "package.json" ] || [ -f "webui/package.json" ]; then
            node_present=true
          fi

          {
            echo "go_present=${go_present}"
            echo "rust_present=${rust_present}"
            echo "node_present=${node_present}"
          } >> "$GITHUB_OUTPUT"

      - name: Setup Go (if go.mod present)
        if: steps.detect_langs.outputs.go_present == 'true'
        uses: actions/setup-go@v6
        with:
          go-version: "1.24"
          cache: true

      - name: Setup Rust (if Cargo.toml present)
        if: steps.detect_langs.outputs.rust_present == 'true'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          components: rustfmt, clippy

      - name: Setup Node.js (if package.json present)
        if: steps.detect_langs.outputs.node_present == 'true'
        uses: actions/setup-node@v6
        with:
          node-version: "22"
          cache: npm
          cache-dependency-path: |
            **/package-lock.json
            webui/package-lock.json

      - name: Load PR Auto-Fix Configuration
        run: |
          echo "Loading Super Linter PR automation configuration..."

          # Check if PR-specific config exists, fallback to default
          if [ -f "super-linter-pr.env" ]; then
            echo "Using PR automation configuration: super-linter-pr.env"
            cat super-linter-pr.env >> "$GITHUB_ENV"
          else
            echo "PR config not found, using default configuration"
            {
              echo "VALIDATE_ALL_CODEBASE=false"
              echo "DEFAULT_BRANCH=${{ github.event.repository.default_branch }}"
              echo "FILTER_REGEX_EXCLUDE=${{ env.FILTER_REGEX_EXCLUDE }}"
            } >> "$GITHUB_ENV"
          fi

      - name: Run Super Linter with Auto-Fix
        id: run-super-linter
        uses: super-linter/super-linter@v8
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for auto-fixes
        id: check-fixes
        run: |
          if ! git diff --quiet; then
            echo "has_fixes=true" >> "$GITHUB_OUTPUT"
            echo "Auto-fixes were applied by Super Linter"
          else
            echo "has_fixes=false" >> "$GITHUB_OUTPUT"
            echo "No auto-fixes were applied"
          fi

      - name: Commit and push auto-fixes
        if: steps.check-fixes.outputs.has_fixes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          echo "Staging auto-fixes..."
          git add -A

          # Create detailed commit message
          FIXED_FILES=$(git diff --cached --name-only | head -10)
          TOTAL_FILES=$(git diff --cached --name-only | wc -l)

          cat <<'EOF' > commit_msg.txt
style: auto-fix linting issues [skip ci]

Auto-formatting and fixes applied by Super Linter.

Files changed:
EOF

          echo "$FIXED_FILES" | while IFS= read -r file; do
            echo "- $file - Auto-formatting applied" >> commit_msg.txt
          done

          if [ "$TOTAL_FILES" -gt 10 ]; then
            echo "- ... and $((TOTAL_FILES - 10)) more files" >> commit_msg.txt
          fi

          {
            echo ""
            echo "Total files changed: $TOTAL_FILES"
            echo ""
            echo "Generated-by: Super Linter"
          } >> commit_msg.txt

          git commit -F commit_msg.txt
          rm commit_msg.txt

          echo "Pushing auto-fixes..."
          git push
          echo "âœ… Auto-fixes committed and pushed successfully"

      - name: Create Job Summary
        if: always()
        run: |
          cat <<'EOF' >> "$GITHUB_STEP_SUMMARY"
# ðŸ” Super Linter Summary
EOF

          if [ "${{ steps.run-super-linter.outcome }}" = "success" ]; then
            echo "âœ… **All code quality checks passed!**" >> "$GITHUB_STEP_SUMMARY"
          elif [ "${{ steps.run-super-linter.outcome }}" = "failure" ]; then
            echo "âŒ **Issues found that need attention**" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "âš ï¸ **Linter status unknown** - check workflow logs" >> "$GITHUB_STEP_SUMMARY"
          fi

          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Show auto-fixes if applied
          if [ "${{ steps.check-fixes.outputs.has_fixes }}" = "true" ]; then
            {
              echo "## ðŸ”§ Auto-fixes Applied"
              echo "Auto-formatting fixes were applied and committed."
              echo ""
            } >> "$GITHUB_STEP_SUMMARY"
          fi

          {
            echo "## Configuration"
            echo "- **Mode**: Changed files only"
            echo "- **Auto-fix**: true"
            echo "- **Auto-commit**: true"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload Super Linter results
        if: always() && hashFiles('super-linter-output/**/*') != ''
        uses: actions/upload-artifact@v5
        with:
          name: super-linter-output-${{ github.run_id }}-${{ github.run_attempt }}
          path: super-linter-output/
          retention-days: 7

      - name: Mark PR Automation Complete
        if: always()
        run: |
          echo "PR_AUTOMATION_COMPLETE=true" >> "$GITHUB_ENV"
          {
            echo "# ðŸŽ¯ PR Automation Complete"
            echo ""
            echo "âœ… **PR automation workflow has completed**"
            echo ""
            echo "- Code quality checks: ${{ steps.run-super-linter.outcome }}"
            echo "- Auto-fixes applied: ${{ steps.check-fixes.outputs.has_fixes }}"
            echo "- CI workflow can now run safely"
          } >> "$GITHUB_STEP_SUMMARY"
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "_This marker allows CI workflows to detect completion of PR automation_" >> $GITHUB_STEP_SUMMARY

          # Create a completion marker file for CI workflows
          mkdir -p .github/workflow-markers
          echo "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > .github/workflow-markers/pr-automation-complete
          echo "PR automation completed at $(date -u +%Y-%m-%dT%H:%M:%SZ)"

  # File-pattern based auto-labeling
  auto-labeling:
    name: Auto Label PR
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Apply file-based labels
        uses: actions/labeler@v6
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          configuration-path: .github/labeler.yml
          sync-labels: true

  # Intelligent AI-powered labeling
  intelligent-labeling:
    name: Intelligent AI Labeling
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' || github.event.action == 'edited'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.13"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests pyyaml python-dateutil scikit-learn nltk

      - name: Download NLTK data
        run: |
          python -c "
          import nltk
          nltk.download('punkt')
          nltk.download('stopwords')
          nltk.download('vader_lexicon')
          "

      - name: Run intelligent labeling
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cat << 'EOF' > intelligent_labeling.py
          import os
          import requests
          import json
          import re
          from collections import defaultdict

          def analyze_pr_content(title, body, changed_files):
              """Basic intelligent labeling based on content analysis"""
              labels = []

              # Analyze title and body
              text = (title + " " + (body or "")).lower()

              # Bug fixes
              if any(word in text for word in ['fix', 'bug', 'error', 'issue', 'problem']):
                  labels.append('bug')

              # Features
              if any(word in text for word in ['feature', 'add', 'new', 'implement']):
                  labels.append('enhancement')

              # Documentation
              if any(word in text for word in ['doc', 'readme', 'documentation']):
                  labels.append('documentation')

              # Tests
              if any(word in text for word in ['test', 'testing', 'spec']):
                  labels.append('tests')

              # Analyze changed files
              for file in changed_files:
                  file_lower = file.lower()
                  if file_lower.endswith(('.md', '.rst')):
                      labels.append('documentation')
                  elif file_lower.endswith(('.go')):
                      labels.append('go')
                  elif file_lower.endswith(('.js', '.ts', '.jsx', '.tsx')):
                      labels.append('frontend')
                  elif file_lower.endswith(('.py')):
                      labels.append('python')
                  elif file_lower.endswith(('dockerfile', '.docker')):
                      labels.append('docker')
                  elif 'test' in file_lower:
                      labels.append('tests')

              return list(set(labels))

          # Get PR information
          github_token = os.environ.get('GITHUB_TOKEN')
          repo = os.environ.get('GITHUB_REPOSITORY')
          pr_number = os.environ.get('PR_NUMBER', '${{ github.event.number }}')

          if not all([github_token, repo, pr_number]):
              print("Missing required environment variables")
              exit(0)

          headers = {
              'Authorization': f'token {github_token}',
              'Accept': 'application/vnd.github.v3+json'
          }

          # Get PR details
          pr_url = f'https://api.github.com/repos/{repo}/pulls/{pr_number}'
          pr_response = requests.get(pr_url, headers=headers)

          if pr_response.status_code != 200:
              print(f"Failed to get PR details: {pr_response.status_code}")
              exit(0)

          pr_data = pr_response.json()

          # Get changed files
          files_url = f'https://api.github.com/repos/{repo}/pulls/{pr_number}/files'
          files_response = requests.get(files_url, headers=headers)

          if files_response.status_code != 200:
              print(f"Failed to get changed files: {files_response.status_code}")
              exit(0)

          changed_files = [f['filename'] for f in files_response.json()]

          # Analyze and suggest labels
          suggested_labels = analyze_pr_content(
              pr_data['title'],
              pr_data['body'],
              changed_files
          )

          print(f"Suggested labels for PR #{pr_number}: {suggested_labels}")

          # Apply labels
          if suggested_labels:
              labels_url = f'https://api.github.com/repos/{repo}/issues/{pr_number}/labels'
              labels_response = requests.post(
                  labels_url,
                  headers=headers,
                  json={'labels': suggested_labels}
              )

              if labels_response.status_code == 200:
                  print(f"âœ… Successfully applied labels: {suggested_labels}")
              else:
                  print(f"âŒ Failed to apply labels: {labels_response.status_code}")
          EOF

          python intelligent_labeling.py

  # PR size and complexity analysis
  pr-analysis:
    name: PR Analysis
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Analyze PR size and complexity
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get changed files and calculate metrics
          CHANGED_FILES=$(git diff --name-only origin/${{ github.event.repository.default_branch }}...HEAD | wc -l)
          ADDED_LINES=$(git diff --numstat origin/${{ github.event.repository.default_branch }}...HEAD | awk '{sum += $1} END {print sum}')
          DELETED_LINES=$(git diff --numstat origin/${{ github.event.repository.default_branch }}...HEAD | awk '{sum += $2} END {print sum}')
          TOTAL_CHANGES=$((ADDED_LINES + DELETED_LINES))

          echo "# ðŸ“Š PR Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Files Changed | $CHANGED_FILES |" >> $GITHUB_STEP_SUMMARY
          echo "| Lines Added | $ADDED_LINES |" >> $GITHUB_STEP_SUMMARY
          echo "| Lines Deleted | $DELETED_LINES |" >> $GITHUB_STEP_SUMMARY
          echo "| Total Changes | $TOTAL_CHANGES |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Determine size label
          if [ $TOTAL_CHANGES -lt 10 ]; then
            SIZE_LABEL="size/XS"
          elif [ $TOTAL_CHANGES -lt 30 ]; then
            SIZE_LABEL="size/S"
          elif [ $TOTAL_CHANGES -lt 100 ]; then
            SIZE_LABEL="size/M"
          elif [ $TOTAL_CHANGES -lt 500 ]; then
            SIZE_LABEL="size/L"
          else
            SIZE_LABEL="size/XL"
          fi

          echo "**Size Classification**: \`$SIZE_LABEL\`" >> $GITHUB_STEP_SUMMARY

          # Apply size label
          curl -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.number }}/labels \
            -d "{\"labels\": [\"$SIZE_LABEL\"]}"

  # Check for breaking changes
  breaking-changes:
    name: Breaking Changes Check
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Check for breaking changes
        run: |
          echo "# ðŸš¨ Breaking Changes Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check commit messages for breaking change indicators
          BREAKING_COMMITS=$(git log --oneline origin/${{ github.event.repository.default_branch }}...HEAD | grep -i "breaking\|BREAKING" || true)

          # Check for API changes in Go files
          API_CHANGES=$(git diff --name-only origin/${{ github.event.repository.default_branch }}...HEAD | grep -E "\.(go)$" | xargs -I {} git diff origin/${{ github.event.repository.default_branch }}...HEAD -- {} | grep -E "^-.*func.*\(" || true)

          if [ -n "$BREAKING_COMMITS" ]; then
            echo "âš ï¸ **Potential breaking changes detected in commits:**" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "$BREAKING_COMMITS" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Apply breaking-change label
            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.number }}/labels \
              -d '{"labels": ["breaking-change"]}'
          else
            echo "âœ… **No breaking changes detected**" >> $GITHUB_STEP_SUMMARY
          fi

  # Conflict resolution helper
  conflict-resolution:
    name: Conflict Resolution
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'synchronize'
    steps:
      - name: Check for merge conflicts
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get PR status
          PR_STATUS=$(curl -s \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.number }} \
            | jq -r '.mergeable')

          echo "# ðŸ”€ Merge Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "$PR_STATUS" = "false" ]; then
            echo "âŒ **Merge conflicts detected**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This PR has merge conflicts that need to be resolved." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Steps to resolve:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Pull the latest changes from the base branch" >> $GITHUB_STEP_SUMMARY
            echo "2. Merge or rebase your branch" >> $GITHUB_STEP_SUMMARY
            echo "3. Resolve any conflicts" >> $GITHUB_STEP_SUMMARY
            echo "4. Push the resolved changes" >> $GITHUB_STEP_SUMMARY

            # Apply needs-rebase label
            curl -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.number }}/labels \
              -d '{"labels": ["needs-rebase"]}'
          elif [ "$PR_STATUS" = "true" ]; then
            echo "âœ… **No merge conflicts**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This PR can be merged cleanly." >> $GITHUB_STEP_SUMMARY

            # Remove needs-rebase label if present
            curl -X DELETE \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.number }}/labels/needs-rebase || true
          else
            echo "â³ **Merge status unknown**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "GitHub is still calculating the merge status." >> $GITHUB_STEP_SUMMARY
          fi

  # PR automation summary
  pr-summary:
    name: PR Automation Summary
    runs-on: ubuntu-latest
    needs: [code-quality, auto-labeling, intelligent-labeling, pr-analysis, attestations, ai-rebase]
    if: always()
    steps:
      - name: Generate summary
        run: |
          echo "# ðŸ¤– PR Automation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.code-quality.result }}" == "success" ]]; then
            echo "âœ… **Code Quality**: Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Code Quality**: Failed" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.auto-labeling.result }}" == "success" ]]; then
            echo "âœ… **Auto Labeling**: Applied" >> $GITHUB_STEP_SUMMARY
          else
            echo "â­ï¸ **Auto Labeling**: Skipped" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.intelligent-labeling.result }}" == "success" ]]; then
            echo "âœ… **AI Labeling**: Applied" >> $GITHUB_STEP_SUMMARY
          else
            echo "â­ï¸ **AI Labeling**: Skipped" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.pr-analysis.result }}" == "success" ]]; then
            echo "âœ… **PR Analysis**: Completed" >> $GITHUB_STEP_SUMMARY
          else
            echo "â­ï¸ **PR Analysis**: Skipped" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.attestations.result }}" == "success" ]]; then
            echo "âœ… **Attestations**: Generated" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.attestations.result }}" == "skipped" ]]; then
            echo "â­ï¸ **Attestations**: Skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Attestations**: Failed" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.ai-rebase.result }}" == "success" ]]; then
            echo "âœ… **AI Rebase**: Completed" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.ai-rebase.result }}" == "skipped" ]]; then
            echo "â­ï¸ **AI Rebase**: Skipped (no conflicts)" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **AI Rebase**: Failed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow completed at**: $(date -u)" >> $GITHUB_STEP_SUMMARY

  # AI-powered rebase and conflict resolution
  ai-rebase:
    name: AI Rebase & Conflict Resolution
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action != 'closed'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Check for merge conflicts
        id: conflict-check
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const pr_number = context.issue.number;

            try {
              let pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr_number,
              });

              // GitHub may return 'unknown' mergeable_state on first request
              if (pr.data.mergeable_state === 'unknown') {
                await new Promise(r => setTimeout(r, 2000));
                pr = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr_number,
                });
              }

              const state = pr.data.mergeable_state;
              core.info(`PR #${pr_number} mergeable state: ${state}`);

              if (state === 'dirty' || state === 'behind') {
                return 'true';
              } else {
                return 'false';
              }
            } catch (error) {
              core.error(`Error checking PR: ${error.message}`);
              return 'false';
            }

      - name: Run AI rebase assistant
        if: steps.conflict-check.outputs.result == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          chmod +x .github/scripts/ai-rebase.sh
          .github/scripts/ai-rebase.sh \
            "${{ github.event.pull_request.number }}" \
            "${{ github.event.pull_request.base.ref }}" \
            "${{ github.event.pull_request.head.ref }}"

  # SBOM generation and provenance attestations (runs on PR for visibility)
  attestations:
    name: SBOM & Provenance Attestations
    runs-on: ubuntu-latest
    needs: [code-quality]
    if: always()
    permissions:
      contents: read
      id-token: write
      actions: read
      attestations: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Generate SBOM (Syft)
        id: generate-sbom
        uses: anchore/sbom-action@v0.20.9
        with:
          output-file: sbom.spdx.json

      - name: Upload SBOM artifact
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: sbom-${{ github.run_id }}-${{ github.run_attempt }}
          path: sbom.spdx.json
          retention-days: 7

      - name: Create attestation bundle
        run: |
          tar -czf pr-automation-context.tar.gz \
            .github/workflows/pr-automation.yml \
            sbom.spdx.json || true
          ls -l pr-automation-context.tar.gz

      - name: Attest SBOM
        uses: actions/attest-sbom@v3
        with:
          subject-path: pr-automation-context.tar.gz
          sbom-path: sbom.spdx.json

      - name: Build Provenance Attestation
        uses: actions/attest-build-provenance@v3
        with:
          subject-path: pr-automation-context.tar.gz

      - name: Attestation summary
        if: always()
        run: |
          echo "# ðŸ›¡ï¸ Attestations" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Generated SBOM (sbom.spdx.json) and created provenance & SBOM attestations." >> $GITHUB_STEP_SUMMARY
            echo "Subject: pr-automation-context.tar.gz" >> $GITHUB_STEP_SUMMARY
