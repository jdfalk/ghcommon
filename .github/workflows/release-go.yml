# file: .github/workflows/release-go.yml
# version: 2.2.1
# guid: e2f3a4b5-c6d7-8e9f-0a1b-2c3d4e5f6a7b

name: Go Release Build

on:
  workflow_call:
    inputs:
      go-matrix:
        description: "Go build matrix configuration"
        required: true
        type: string
      protobuf-artifacts:
        description: "Whether protobuf artifacts are available"
        required: false
        type: string
        default: "false"

permissions:
  contents: write # needed for release asset upload
  packages: write

env:
  GOPROXY: https://proxy.golang.org,direct
  GOSUMDB: sum.golang.org
  GOPRIVATE: github.com/${{ github.repository_owner }}/*
  GONOSUMDB: github.com/${{ github.repository_owner }}/*

jobs:
  # Go matrix build with all our improvements from matrix-build.yml
  build-go:
    name: Build Go (${{ matrix.go-version }} on ${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(inputs.go-matrix) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Download protobuf artifacts
        if: inputs.protobuf-artifacts == 'true'
        uses: actions/download-artifact@v6
        with:
          name: protobuf-generated

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ matrix.go-version }}
          cache: true

      - name: Build Go project
        run: |
          go mod download
          go build -v ./...

      - name: Test Go project
        run: |
          go test -v -race -coverprofile=coverage.out ./...

      - name: Upload coverage (primary only)
        if: matrix.primary
        uses: actions/upload-artifact@v4
        with:
          name: go-coverage-${{ matrix.os }}-${{ matrix.go-version }}
          path: coverage.out

      - name: Package Go build artifacts
        run: |
          set -euo pipefail
          mkdir -p dist
          # Detect all main packages
          PKGS=$(go list -f '{{if eq .Name "main"}}{{.ImportPath}}{{end}}' ./... | grep -v '^$' || true)
          if [ -z "${PKGS}" ]; then
            echo "No main packages found; creating marker file so artifact upload still succeeds." >&2
            echo "This module contains no main packages (library-only)." > dist/README.txt
          else
            echo "Building main packages: ${PKGS}" >&2
            for pkg in ${PKGS}; do
              name=$(basename "${pkg}")
              out="dist/${name}-${{ matrix.os }}-${{ matrix.go-version }}"
              # Add .exe if a Windows runner is ever introduced
              case "${{ matrix.os }}" in
                *windows*) out="${out}.exe" ;;
              esac
              echo "go build -o ${out} ${pkg}" >&2
              go build -o "${out}" "${pkg}"
            done
          fi
          # Mark primary builds so aggregator can filter (written only if matrix.primary==true)
          if [ "${{ matrix.primary }}" = "true" ]; then
            touch dist/_primary.marker
          fi
          echo "Contents of dist/:"
          ls -l dist

      - name: Upload Go build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: go-build-${{ matrix.os }}-${{ matrix.go-version }}
          path: dist/

  detect-go-module:
    name: Detect Go Module
    runs-on: ubuntu-latest
    needs: build-go
    if: startsWith(github.ref, 'refs/tags/v')
    outputs:
      has-module: ${{ steps.detect.outputs.has-module }}
      module-path: ${{ steps.detect.outputs.module-path }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Detect module
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          if [[ -f "go.mod" ]]; then
            MODULE_PATH=$(awk '/^module[[:space:]]+/ {print $2; exit}' go.mod)
            if [[ -n "$MODULE_PATH" ]]; then
              echo "has-module=true" >> "$GITHUB_OUTPUT"
              echo "module-path=${MODULE_PATH}" >> "$GITHUB_OUTPUT"
              echo "✅ Detected Go module: ${MODULE_PATH}"
            else
              echo "has-module=false" >> "$GITHUB_OUTPUT"
              echo "::warning::go.mod present but module path missing."
            fi
          else
            echo "has-module=false" >> "$GITHUB_OUTPUT"
            echo "::warning::No go.mod found; skipping Go module publishing."
          fi

      - name: Detection summary
        if: always()
        shell: bash
        run: |
          {
            echo "# Go Module Detection"
            echo ""
            if [[ "${{ steps.detect.outputs.has-module }}" == "true" ]]; then
              echo "- Module detected: \`${{ steps.detect.outputs.module-path }}\`"
            else
              echo "- No Go module detected. Publishing jobs will be skipped."
            fi
          } >> "$GITHUB_STEP_SUMMARY"

  validate-go-module:
    name: Validate Go Module
    runs-on: ubuntu-latest
    needs: [build-go, detect-go-module]
    if: |
      startsWith(github.ref, 'refs/tags/v') &&
      needs.detect-go-module.outputs.has-module == 'true'
    outputs:
      is-valid: ${{ steps.validation-result.outputs.is-valid }}
      module-path: ${{ steps.extract-info.outputs.module-path }}
      module-version: ${{ steps.extract-info.outputs.module-version }}
      major-version: ${{ steps.extract-info.outputs.major-version }}
      validation-errors: ${{ steps.validation-result.outputs.errors }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Extract module information
        id: extract-info
        shell: bash
        run: |
          set -euo pipefail

          MODULE_PATH=$(awk '/^module[[:space:]]+/ {print $2; exit}' go.mod)
          if [[ -z "${MODULE_PATH}" ]]; then
            echo "::error::Unable to determine module path from go.mod"
            exit 1
          fi

          TAG_VERSION="${GITHUB_REF#refs/tags/v}"
          if [[ -z "${TAG_VERSION}" ]]; then
            echo "::error::Unable to determine version from tag ${GITHUB_REF}"
            exit 1
          fi

          MAJOR_VERSION="${TAG_VERSION%%.*}"

          {
            echo "module-path=${MODULE_PATH}"
            echo "module-version=${TAG_VERSION}"
            echo "major-version=${MAJOR_VERSION}"
          } >> "$GITHUB_OUTPUT"

          {
            echo "# Go Module Validation"
            echo ""
            echo "- Module path: \`${MODULE_PATH}\`"
            echo "- Version tag: \`v${TAG_VERSION}\`"
            echo "- Major version: \`${MAJOR_VERSION}\`"
            echo ""
            echo "go.mod:"
            sed 's/^/    /' go.mod
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Validate module path
        id: validate-path
        shell: bash
        run: |
          set -euo pipefail

          MODULE_PATH="${{ steps.extract-info.outputs.module-path }}"
          EXPECTED_PREFIX="github.com/${{ github.repository }}"

          if [[ "${MODULE_PATH}" == "${EXPECTED_PREFIX}"* ]]; then
            echo "path-valid=true" >> "$GITHUB_OUTPUT"
            echo "✅ Module path matches repository: ${MODULE_PATH}"
          else
            echo "path-valid=false" >> "$GITHUB_OUTPUT"
            echo "::error::Module path ${MODULE_PATH} does not reside under ${EXPECTED_PREFIX}"
            exit 1
          fi

          if [[ "${MODULE_PATH}" =~ [A-Z] ]]; then
            echo "::warning::Module path contains uppercase characters. Go module paths should be lowercase."
          fi

      - name: Validate semantic version
        id: validate-version
        shell: bash
        run: |
          set -euo pipefail

          VERSION="${{ steps.extract-info.outputs.module-version }}"
          if [[ "${VERSION}" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z.-]+)?(\+[0-9A-Za-z.-]+)?$ ]]; then
            echo "version-valid=true" >> "$GITHUB_OUTPUT"
            echo "✅ Version ${VERSION} is a valid semantic version"
          else
            echo "version-valid=false" >> "$GITHUB_OUTPUT"
            echo "::error::Version ${VERSION} is not a valid semantic version (expected X.Y.Z)"
            exit 1
          fi

      - name: Validate major version alignment
        id: validate-major-version
        shell: bash
        run: |
          set -euo pipefail

          MODULE_PATH="${{ steps.extract-info.outputs.module-path }}"
          MAJOR="${{ steps.extract-info.outputs.major-version }}"

          if [[ "${MAJOR}" =~ ^[0-9]+$ ]]; then
            if (( MAJOR >= 2 )); then
              if [[ "${MODULE_PATH}" == *"/v${MAJOR}" ]]; then
                echo "aligned=true" >> "$GITHUB_OUTPUT"
                echo "✅ Module path includes /v${MAJOR} for major version ${MAJOR}"
              else
                echo "aligned=false" >> "$GITHUB_OUTPUT"
                echo "::error::Major version ${MAJOR} requires module path to end with /v${MAJOR}"
                exit 1
              fi
            else
              if [[ "${MODULE_PATH}" == *"/v"?(0|1)* ]]; then
                echo "::warning::Module path includes version suffix but major version is ${MAJOR}; verify module path."
              fi
              echo "aligned=true" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "aligned=false" >> "$GITHUB_OUTPUT"
            echo "::error::Unable to determine numeric major version from ${MAJOR}"
            exit 1
          fi

      - name: Validate go.mod and dependencies
        id: validate-gomod
        shell: bash
        run: |
          set -euo pipefail

          echo "Running go mod verify..."
          go mod verify

          if [[ ! -f go.sum ]]; then
            echo "::warning::go.sum not found; generating..."
            go mod tidy
          fi

          echo "Downloading dependencies..."
          go mod download

          echo "Checking for tidy go.mod/go.sum..."
          go mod tidy
          if git diff --quiet -- go.mod go.sum; then
            echo "tidy=true" >> "$GITHUB_OUTPUT"
            echo "✅ go.mod and go.sum are tidy"
          else
            echo "tidy=false" >> "$GITHUB_OUTPUT"
            echo "::warning::go.mod or go.sum would change after go mod tidy. Please run go mod tidy locally."
            git --no-pager diff -- go.mod go.sum
          fi

          echo "gomod-valid=true" >> "$GITHUB_OUTPUT"

      - name: Build and test module
        id: check-compat
        shell: bash
        run: |
          set -euo pipefail

          echo "Building module..."
          if go build ./...; then
            echo "build-success=true" >> "$GITHUB_OUTPUT"
            echo "✅ Module builds successfully"
          else
            echo "build-success=false" >> "$GITHUB_OUTPUT"
            echo "::error::Module build failed"
            exit 1
          fi

          echo "Running tests..."
          if go test ./... -short; then
            echo "tests-pass=true" >> "$GITHUB_OUTPUT"
            echo "✅ Tests passed"
          else
            echo "tests-pass=false" >> "$GITHUB_OUTPUT"
            echo "::warning::Some tests failed"
          fi

          echo "Running go vet..."
          if go vet ./...; then
            echo "vet-pass=true" >> "$GITHUB_OUTPUT"
          else
            echo "vet-pass=false" >> "$GITHUB_OUTPUT"
            echo "::warning::go vet reported issues"
          fi

      - name: Validation summary
        id: validation-result
        shell: bash
        run: |
          set -euo pipefail

          ERRORS=""
          WARNINGS=""

          [[ "${{ steps.validate-path.outputs.path-valid }}" == "true" ]] || ERRORS+="Module path invalid. "
          [[ "${{ steps.validate-version.outputs.version-valid }}" == "true" ]] || ERRORS+="Version format invalid. "
          [[ "${{ steps.validate-major-version.outputs.aligned }}" == "true" ]] || ERRORS+="Major version misalignment. "
          [[ "${{ steps.validate-gomod.outputs.gomod-valid }}" == "true" ]] || ERRORS+="go.mod verification failed. "
          [[ "${{ steps.check-compat.outputs.build-success }}" == "true" ]] || ERRORS+="Module build failed. "

          [[ "${{ steps.validate-gomod.outputs.tidy }}" == "true" ]] || WARNINGS+="go mod tidy changes detected. "
          [[ "${{ steps.check-compat.outputs.tests-pass }}" == "true" ]] || WARNINGS+="Tests did not pass. "
          [[ "${{ steps.check-compat.outputs.vet-pass }}" == "true" ]] || WARNINGS+="go vet reported issues. "

          echo "errors=${ERRORS}" >> "$GITHUB_OUTPUT"

          if [[ -n "${ERRORS}" ]]; then
            echo "is-valid=false" >> "$GITHUB_OUTPUT"
            echo "::error::Go module validation failed: ${ERRORS}"
            exit 1
          fi

          if [[ -n "${WARNINGS}" ]]; then
            echo "::warning::Go module validation warnings: ${WARNINGS}"
          fi

          echo "is-valid=true" >> "$GITHUB_OUTPUT"

      - name: Upload validation report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: go-module-validation-report
          path: |
            go.mod
            go.sum
          retention-days: 30

  aggregate-artifacts:
    name: Aggregate Go Build Artifacts
    needs: build-go
    runs-on: ubuntu-latest
    steps:
      - name: Create workspace
        run: mkdir -p combined

      - name: Download all build artifacts
        uses: actions/download-artifact@v6
        with:
          path: combined/raw

      - name: Normalize structure & collect executables
        run: |
          set -euo pipefail
          cd combined/raw
          echo "Downloaded artifact contents (truncated):" >&2
          find . -maxdepth 3 -type f | head -100
          mkdir -p ../final
          PRIMARY_DIRS=$(find . -name _primary.marker -exec dirname {} \; | sort -u || true)
          if [ -n "$PRIMARY_DIRS" ]; then
            echo "Primary marker directories detected; limiting aggregation to primary builds:" >&2
            echo "$PRIMARY_DIRS" >&2
            TARGET_DIRS="$PRIMARY_DIRS"
          else
            echo "No primary markers found; aggregating all build artifacts." >&2
            TARGET_DIRS=$(find . -type d -mindepth 1 -maxdepth 3 | sort -u)
          fi
          copied=0
          dupes=0
          for d in $TARGET_DIRS; do
            for f in $(find "$d" -maxdepth 1 -type f 2>/dev/null || true); do
              base=$(basename "$f")
              [ "$base" = "_primary.marker" ] && continue
              case "$base" in *.txt|*.md|*.sha256|*.sig|*.spdx.json) continue ;; esac
              if [ -x "$f" ] || [[ ! "$base" == *.* ]]; then
                if [ -f "../final/$base" ]; then
                  echo "Duplicate artifact name $base (keeping first)" >&2
                  dupes=$((dupes+1))
                  continue
                fi
                cp "$f" ../final/"$base"
                chmod +x ../final/"$base" || true
                copied=$((copied+1))
              fi
            done
            if [ -f "$d/README.txt" ]; then
              base_dir=$(basename "$d")
              cp "$d/README.txt" ../final/"${base_dir}-README.txt"
            fi
          done
          if [ $copied -eq 0 ]; then
            echo "No executable artifacts detected; creating placeholder." >&2
            echo "No executables found in selected directories" > ../final/NO_EXECUTABLES.txt
          fi
          echo "Copied $copied executables ($dupes duplicate names skipped)" >&2
          ls -l ../final

      - name: Create per-OS archives
        run: |
          set -euo pipefail
          cd combined/final
          mkdir -p ../../per-os
          for f in *; do
            [ -f "$f" ] || continue
            name="$f"
            osToken="generic"
            case "$name" in
              *linux*) osToken=linux ;;
              *ubuntu*) osToken=linux ;;
              *darwin*|*macos*) osToken=darwin ;;
              *windows*) osToken=windows ;;
            esac
            mkdir -p "../../per-os/$osToken"
            cp "$f" "../../per-os/$osToken/"
          done
          cd ../../per-os
          for d in *; do
            [ -d "$d" ] || continue
            tar -czf "go-build-$d.tar.gz" -C "$d" .
            zip -r "go-build-$d.zip" "$d" >/dev/null
          done
          ls -l

      - name: Create tarball and zip
        run: |
          cd combined/final
          tar -czf ../../go-build-all.tar.gz .
          zip -r ../../go-build-all.zip .

      - name: Generate checksums
        run: |
          set -euo pipefail
          sha256sum go-build-all.tar.gz > go-build-all.tar.gz.sha256
          sha256sum go-build-all.zip > go-build-all.zip.sha256
          if [ -d per-os ]; then
            (cd per-os && for f in *.tar.gz *.zip; do [ -f "$f" ] && sha256sum "$f" > "$f.sha256" 2>/dev/null || true; done)
          fi
          echo "Generated checksums:" >&2
          cat go-build-all.tar.gz.sha256
          cat go-build-all.zip.sha256

      - name: Generate SBOM (syft)
        run: |
          set -euo pipefail
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin > /dev/null 2>&1 || echo "Syft install fallback"
          if command -v syft >/dev/null 2>&1; then
            syft combined/final -o spdx-json=go-build-all.sbom.spdx.json || echo "Syft scan failed (non-fatal)"
            if [ -d per-os ]; then
              for d in per-os/*.tar.gz; do
                [ -f "$d" ] || continue
                syft "$d" -o spdx-json="${d}.sbom.spdx.json" || true
              done
            fi
          else
            echo "Syft not installed; skipping SBOM generation" >&2
          fi

      - name: Install Cosign
        uses: sigstore/cosign-installer@v4.0.0
        with:
          cosign-release: "v2.4.1"

      - name: Sign artifacts with Cosign
        env:
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
        run: |
          set -euo pipefail

          # Check if we have the private key for signing
          if [ -z "${COSIGN_PRIVATE_KEY:-}" ]; then
            echo "COSIGN_PRIVATE_KEY not set, skipping artifact signing" >&2
            exit 0
          fi

          echo "Signing artifacts with cosign using repository certificate" >&2

          # Sign aggregate artifacts
          for f in go-build-all.tar.gz go-build-all.zip; do
            [ -f "$f" ] || continue
            echo "Signing $f..." >&2
            cosign sign-blob --key env://COSIGN_PRIVATE_KEY --output-signature "$f.sig" "$f" || echo "Failed to sign $f" >&2
          done

          # Sign per-os artifacts if they exist
          if [ -d per-os ]; then
            for f in per-os/*.{tar.gz,zip}; do
              [ -f "$f" ] || continue
              echo "Signing $f..." >&2
              cosign sign-blob --key env://COSIGN_PRIVATE_KEY --output-signature "$f.sig" "$f" || echo "Failed to sign $f" >&2
            done
          fi

          echo "Artifact signing completed" >&2

      - name: Upload signature files
        uses: actions/upload-artifact@v4
        with:
          name: go-build-signatures
          path: |
            *.sig
            per-os/*.sig
        continue-on-error: true

      - name: Save public key for upload
        env:
          COSIGN_PUBLIC_KEY: ${{ secrets.COSIGN_PUBLIC_KEY }}
        run: |
          if [ -n "${COSIGN_PUBLIC_KEY:-}" ]; then
            echo "$COSIGN_PUBLIC_KEY" > cosign.pub
          else
            echo "COSIGN_PUBLIC_KEY secret not set, using repository file" >&2
          fi

      - name: Upload cosign public key
        uses: actions/upload-artifact@v4
        with:
          name: cosign-public-key
          path: cosign.pub

      - name: Upload checksum artifacts
        uses: actions/upload-artifact@v4
        with:
          name: go-build-all-checksums
          path: |
            go-build-all.tar.gz.sha256
            go-build-all.zip.sha256
            per-os/*.sha256

      - name: Upload SBOMs
        uses: actions/upload-artifact@v4
        with:
          name: go-build-sboms
          path: |
            go-build-all.sbom.spdx.json
            per-os/*.sbom.spdx.json

      - name: Upload signatures (if any)
        uses: actions/upload-artifact@v4
        with:
          name: go-build-signatures
          path: |
            go-build-all.tar.gz.sig
            go-build-all.zip.sig
            per-os/*.sig

      - name: Upload combined artifact (tar.gz)
        uses: actions/upload-artifact@v4
        with:
          name: go-build-all-tar
          path: go-build-all.tar.gz

      - name: Upload combined artifact (zip)
        uses: actions/upload-artifact@v4
        with:
          name: go-build-all-zip
          path: go-build-all.zip

      - name: Upload per-OS archives
        if: hashFiles('per-os/*') != ''
        uses: actions/upload-artifact@v4
        with:
          name: go-build-per-os
          path: per-os/

  publish-go-module:
    name: Publish Go Module
    runs-on: ubuntu-latest
    needs: [build-go, validate-go-module]
    if: |
      startsWith(github.ref, 'refs/tags/v') &&
      needs.validate-go-module.outputs.is-valid == 'true'
    permissions:
      contents: write
      packages: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Display publishing context
        id: context
        shell: bash
        run: |
          set -euo pipefail
          MODULE_PATH="${{ needs.validate-go-module.outputs.module-path }}"
          MODULE_VERSION="${{ needs.validate-go-module.outputs.module-version }}"
          TAG_NAME="${GITHUB_REF#refs/tags/}"

          echo "module-path=${MODULE_PATH}" >> "$GITHUB_OUTPUT"
          echo "module-version=${MODULE_VERSION}" >> "$GITHUB_OUTPUT"
          echo "tag-name=${TAG_NAME}" >> "$GITHUB_OUTPUT"

          {
            echo "# Go Module Publishing"
            echo ""
            echo "- Module: \`${MODULE_PATH}\`"
            echo "- Version: \`${TAG_NAME}\`"
            echo "- Repository: \`${{ github.repository }}\`"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Verify Git tag
        shell: bash
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF#refs/tags/}"
          if git rev-parse "${TAG}" >/dev/null 2>&1; then
            echo "✅ Tag ${TAG} exists at $(git rev-parse "${TAG}")"
          else
            echo "::error::Tag ${TAG} not found in repository"
            exit 1
          fi

      - name: Create module archive
        id: create-archive
        shell: bash
        run: |
          set -euo pipefail
          MODULE_PATH="${{ steps.context.outputs.module-path }}"
          VERSION="${{ steps.context.outputs.module-version }}"
          SAFE_MODULE="${MODULE_PATH//\//_}"
          ZIP_NAME="${SAFE_MODULE}@v${VERSION}.zip"

          echo "Creating archive ${ZIP_NAME}"
          zip -qr "${ZIP_NAME}" . \
            -x ".git/*" \
            -x ".github/workflows/*" \
            -x "*.zip" \
            -x "dist/*" \
            -x "target/*" \
            -x "node_modules/*"

          if [[ ! -f "${ZIP_NAME}" ]]; then
            echo "::error::Failed to create module archive ${ZIP_NAME}"
            exit 1
          fi

          echo "zip-name=${ZIP_NAME}" >> "$GITHUB_OUTPUT"
          echo "✅ Module archive created: ${ZIP_NAME}"

      - name: Generate module metadata
        id: metadata
        env:
          MODULE_PATH: ${{ steps.context.outputs.module-path }}
          MODULE_VERSION: ${{ steps.context.outputs.module-version }}
          REPOSITORY: ${{ github.repository }}
          TAG_NAME: ${{ steps.context.outputs.tag-name }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          python3 .github/workflows/scripts/write_go_module_metadata.py

      - name: Test module discoverability
        id: discoverability
        shell: bash
        run: |
          set -euo pipefail

          MODULE="${{ steps.context.outputs.module-path }}"
          VERSION="${{ steps.context.outputs.tag-name }}"

          echo "Checking module availability for ${MODULE}@${VERSION}"
          if GOPRIVATE=github.com/${{ github.repository_owner }}/* GONOSUMDB=off GOPROXY=direct go list -m "${MODULE}@${VERSION}"; then
            echo "discoverable=true" >> "$GITHUB_OUTPUT"
            echo "✅ Module is discoverable via go list"
          else
            echo "discoverable=false" >> "$GITHUB_OUTPUT"
            echo "::warning::Module may require additional propagation time before it is discoverable."
          fi

      - name: Publish to GitHub Packages (best effort)
        id: gh-packages
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail

          MODULE="${{ steps.context.outputs.module-path }}"
          VERSION="v${{ steps.context.outputs.module-version }}"
          ZIP="${{ steps.create-archive.outputs.zip-name }}"
          PACKAGE_ENDPOINT="https://api.github.com/repos/${{ github.repository }}/packages/go/${{ github.event.repository.name }}/versions"

          echo "Attempting to publish ${ZIP} to GitHub Packages (${PACKAGE_ENDPOINT})"
          RESPONSE=$(curl -sS -X POST \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -F "package=@${ZIP}" \
            "${PACKAGE_ENDPOINT}" \
            -w "\nHTTP_STATUS:%{http_code}" || true)

          STATUS=$(echo "${RESPONSE}" | awk -F: '/HTTP_STATUS/ {print $2}')

          if [[ "${STATUS}" == "200" || "${STATUS}" == "201" ]]; then
            echo "uploaded=true" >> "$GITHUB_OUTPUT"
            echo "✅ Package upload reported success (HTTP ${STATUS})"
          else
            echo "uploaded=false" >> "$GITHUB_OUTPUT"
            echo "::warning::GitHub Packages upload returned HTTP ${STATUS}. Go modules rely primarily on Git tags; continuing."
          fi

      - name: Upload publishing artifacts
        uses: actions/upload-artifact@v4
        with:
          name: go-module-${{ steps.context.outputs.tag-name }}
          path: |
            ${{ steps.create-archive.outputs.zip-name }}
            ${{ steps.metadata.outputs.metadata-file }}
          retention-days: 90

      - name: Publishing summary
        if: always()
        shell: bash
        run: |
          {
            echo ""
            echo "## Go Module Publishing Status"
            echo ""
            echo "- Module: \`${{ steps.context.outputs.module-path }}\`"
            echo "- Version: \`${{ steps.context.outputs.tag-name }}\`"
            echo "- Archive: \`${{ steps.create-archive.outputs.zip-name }}\`"
            echo "- Discoverable: ${{ steps.discoverability.outputs.discoverable == 'true' && '✅ Yes' || '⏳ Pending' }}"
            echo "- GitHub Packages upload: ${{ steps.gh-packages.outputs.uploaded == 'true' && '✅ Succeeded' || '⚠️ Skipped/Failed' }}"
            echo ""
            echo "Install with:"
            echo ""
            echo '```bash'
            echo "go get ${{ steps.context.outputs.module-path }}@${{ steps.context.outputs.tag-name }}"
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

  publish-release:
    name: Publish GitHub Release
    needs:
      - aggregate-artifacts
      - publish-go-module
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Download combined tar
        uses: actions/download-artifact@v6
        with:
          name: go-build-all-tar
          path: artifacts
      - name: Download combined zip
        uses: actions/download-artifact@v6
        with:
          name: go-build-all-zip
          path: artifacts
      - name: Download checksums
        uses: actions/download-artifact@v6
        with:
          name: go-build-all-checksums
          path: artifacts
      - name: Download per-OS archives
        uses: actions/download-artifact@v6
        with:
          name: go-build-per-os
          path: artifacts/per-os
        continue-on-error: true
      - name: Download SBOMs
        uses: actions/download-artifact@v6
        with:
          name: go-build-sboms
          path: artifacts/sboms
        continue-on-error: true
      - name: Download signatures
        uses: actions/download-artifact@v6
        with:
          name: go-build-signatures
          path: artifacts/signatures
        continue-on-error: true
      - name: Download module artifacts
        uses: actions/download-artifact@v6
        with:
          name: go-module-${{ github.ref_name }}
          path: artifacts/module
        continue-on-error: true
      - name: Prepare release assets
        run: |
          set -euo pipefail
          ls -R artifacts | head -200
          find artifacts -type f -maxdepth 4 -exec cp {} . \;
          ls -l .
      - name: Create / Update Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            go-build-all.tar.gz
            go-build-all.zip
            go-build-all.tar.gz.sha256
            go-build-all.zip.sha256
            go-build-all.sbom.spdx.json
            go-build-all.tar.gz.sig
            go-build-all.zip.sig
            go-build-*.tar.gz
            go-build-*.zip
            go-build-*.tar.gz.sha256
            go-build-*.zip.sha256
            go-build-*.sbom.spdx.json
            go-build-*.sig
            go-module-*.zip
            module-metadata.json
          draft: false
          prerelease: false
