# file: .github/workflows/release-go.yml
# version: 1.4.1
# guid: e2f3a4b5-c6d7-8e9f-0a1b-2c3d4e5f6a7b

name: Go Release Build

on:
  workflow_call:
    inputs:
      go-matrix:
        description: "Go build matrix configuration"
        required: true
        type: string
      protobuf-artifacts:
        description: "Whether protobuf artifacts are available"
        required: false
        type: string
        default: "false"

permissions:
  contents: write # needed for release asset upload
  packages: write

jobs:
  # Go matrix build with all our improvements from matrix-build.yml
  build-go:
    name: Build Go (${{ matrix.go-version }} on ${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(inputs.go-matrix) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Download protobuf artifacts
        if: inputs.protobuf-artifacts == 'true'
        uses: actions/download-artifact@v5
        with:
          name: protobuf-generated

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ matrix.go-version }}
          cache: true

      - name: Build Go project
        run: |
          go mod download
          go build -v ./...

      - name: Test Go project
        run: |
          go test -v -race -coverprofile=coverage.out ./...

      - name: Upload coverage (primary only)
        if: matrix.primary
        uses: actions/upload-artifact@v4
        with:
          name: go-coverage-${{ matrix.os }}-${{ matrix.go-version }}
          path: coverage.out

      - name: Package Go build artifacts
        run: |
          set -euo pipefail
          mkdir -p dist
          # Detect all main packages
          PKGS=$(go list -f '{{if eq .Name "main"}}{{.ImportPath}}{{end}}' ./... | grep -v '^$' || true)
          if [ -z "${PKGS}" ]; then
            echo "No main packages found; creating marker file so artifact upload still succeeds." >&2
            echo "This module contains no main packages (library-only)." > dist/README.txt
          else
            echo "Building main packages: ${PKGS}" >&2
            for pkg in ${PKGS}; do
              name=$(basename "${pkg}")
              out="dist/${name}-${{ matrix.os }}-${{ matrix.go-version }}"
              # Add .exe if a Windows runner is ever introduced
              case "${{ matrix.os }}" in
                *windows*) out="${out}.exe" ;;
              esac
              echo "go build -o ${out} ${pkg}" >&2
              go build -o "${out}" "${pkg}"
            done
          fi
          # Mark primary builds so aggregator can filter (written only if matrix.primary==true)
          if [ "${{ matrix.primary }}" = "true" ]; then
            touch dist/_primary.marker
          fi
          echo "Contents of dist/:"
          ls -l dist

      - name: Upload Go build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: go-build-${{ matrix.os }}-${{ matrix.go-version }}
          path: dist/

  aggregate-artifacts:
    name: Aggregate Go Build Artifacts
    needs: build-go
    runs-on: ubuntu-latest
    steps:
      - name: Create workspace
        run: mkdir -p combined

      - name: Download all build artifacts
        uses: actions/download-artifact@v5
        with:
          path: combined/raw

      - name: Normalize structure & collect executables
        run: |
          set -euo pipefail
          cd combined/raw
          echo "Downloaded artifact contents (truncated):" >&2
          find . -maxdepth 3 -type f | head -100
          mkdir -p ../final
          PRIMARY_DIRS=$(find . -name _primary.marker -exec dirname {} \; | sort -u || true)
          if [ -n "$PRIMARY_DIRS" ]; then
            echo "Primary marker directories detected; limiting aggregation to primary builds:" >&2
            echo "$PRIMARY_DIRS" >&2
            TARGET_DIRS="$PRIMARY_DIRS"
          else
            echo "No primary markers found; aggregating all build artifacts." >&2
            TARGET_DIRS=$(find . -type d -mindepth 1 -maxdepth 3 | sort -u)
          fi
          copied=0
          dupes=0
          for d in $TARGET_DIRS; do
            for f in $(find "$d" -maxdepth 1 -type f 2>/dev/null || true); do
              base=$(basename "$f")
              [ "$base" = "_primary.marker" ] && continue
              case "$base" in *.txt|*.md|*.sha256|*.sig|*.spdx.json) continue ;; esac
              if [ -x "$f" ] || [[ ! "$base" == *.* ]]; then
                if [ -f "../final/$base" ]; then
                  echo "Duplicate artifact name $base (keeping first)" >&2
                  dupes=$((dupes+1))
                  continue
                fi
                cp "$f" ../final/"$base"
                chmod +x ../final/"$base" || true
                copied=$((copied+1))
              fi
            done
            if [ -f "$d/README.txt" ]; then
              base_dir=$(basename "$d")
              cp "$d/README.txt" ../final/"${base_dir}-README.txt"
            fi
          done
          if [ $copied -eq 0 ]; then
            echo "No executable artifacts detected; creating placeholder." >&2
            echo "No executables found in selected directories" > ../final/NO_EXECUTABLES.txt
          fi
          echo "Copied $copied executables ($dupes duplicate names skipped)" >&2
          ls -l ../final

      - name: Create per-OS archives
        run: |
          set -euo pipefail
          cd combined/final
          mkdir -p ../../per-os
          for f in *; do
            [ -f "$f" ] || continue
            name="$f"
            osToken="generic"
            case "$name" in
              *linux*) osToken=linux ;;
              *ubuntu*) osToken=linux ;;
              *darwin*|*macos*) osToken=darwin ;;
              *windows*) osToken=windows ;;
            esac
            mkdir -p "../../per-os/$osToken"
            cp "$f" "../../per-os/$osToken/"
          done
          cd ../../per-os
          for d in *; do
            [ -d "$d" ] || continue
            tar -czf "go-build-$d.tar.gz" -C "$d" .
            zip -r "go-build-$d.zip" "$d" >/dev/null
          done
          ls -l

      - name: Create tarball and zip
        run: |
          cd combined/final
          tar -czf ../../go-build-all.tar.gz .
          zip -r ../../go-build-all.zip .

      - name: Generate checksums
        run: |
          set -euo pipefail
          sha256sum go-build-all.tar.gz > go-build-all.tar.gz.sha256
          sha256sum go-build-all.zip > go-build-all.zip.sha256
          if [ -d per-os ]; then
            (cd per-os && for f in *.tar.gz *.zip; do [ -f "$f" ] && sha256sum "$f" > "$f.sha256" 2>/dev/null || true; done)
          fi
          echo "Generated checksums:" >&2
          cat go-build-all.tar.gz.sha256
          cat go-build-all.zip.sha256

      - name: Generate SBOM (syft)
        run: |
          set -euo pipefail
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin > /dev/null 2>&1 || echo "Syft install fallback"
          if command -v syft >/dev/null 2>&1; then
            syft combined/final -o spdx-json=go-build-all.sbom.spdx.json || echo "Syft scan failed (non-fatal)"
            if [ -d per-os ]; then
              for d in per-os/*.tar.gz; do
                [ -f "$d" ] || continue
                syft "$d" -o spdx-json="${d}.sbom.spdx.json" || true
              done
            fi
          else
            echo "Syft not installed; skipping SBOM generation" >&2
          fi

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.9.2
        with:
          cosign-release: "v2.4.1"

      - name: Sign artifacts with Cosign
        env:
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
        run: |
          set -euo pipefail

          # Check if we have the private key for signing
          if [ -z "${COSIGN_PRIVATE_KEY:-}" ]; then
            echo "COSIGN_PRIVATE_KEY not set, skipping artifact signing" >&2
            exit 0
          fi

          echo "Signing artifacts with cosign using repository certificate" >&2

          # Sign aggregate artifacts
          for f in go-build-all.tar.gz go-build-all.zip; do
            [ -f "$f" ] || continue
            echo "Signing $f..." >&2
            cosign sign-blob --key env://COSIGN_PRIVATE_KEY --output-signature "$f.sig" "$f" || echo "Failed to sign $f" >&2
          done

          # Sign per-os artifacts if they exist
          if [ -d per-os ]; then
            for f in per-os/*.{tar.gz,zip}; do
              [ -f "$f" ] || continue
              echo "Signing $f..." >&2
              cosign sign-blob --key env://COSIGN_PRIVATE_KEY --output-signature "$f.sig" "$f" || echo "Failed to sign $f" >&2
            done
          fi

          echo "Artifact signing completed" >&2

      - name: Upload signature files
        uses: actions/upload-artifact@v4
        with:
          name: go-build-signatures
          path: |
            *.sig
            per-os/*.sig
        continue-on-error: true

      - name: Save public key for upload
        env:
          COSIGN_PUBLIC_KEY: ${{ secrets.COSIGN_PUBLIC_KEY }}
        run: |
          if [ -n "${COSIGN_PUBLIC_KEY:-}" ]; then
            echo "$COSIGN_PUBLIC_KEY" > cosign.pub
          else
            echo "COSIGN_PUBLIC_KEY secret not set, using repository file" >&2
          fi

      - name: Upload cosign public key
        uses: actions/upload-artifact@v4
        with:
          name: cosign-public-key
          path: cosign.pub

      - name: Upload checksum artifacts
        uses: actions/upload-artifact@v4
        with:
          name: go-build-all-checksums
          path: |
            go-build-all.tar.gz.sha256
            go-build-all.zip.sha256
            per-os/*.sha256

      - name: Upload SBOMs
        uses: actions/upload-artifact@v4
        with:
          name: go-build-sboms
          path: |
            go-build-all.sbom.spdx.json
            per-os/*.sbom.spdx.json

      - name: Upload signatures (if any)
        uses: actions/upload-artifact@v4
        with:
          name: go-build-signatures
          path: |
            go-build-all.tar.gz.sig
            go-build-all.zip.sig
            per-os/*.sig

      - name: Upload combined artifact (tar.gz)
        uses: actions/upload-artifact@v4
        with:
          name: go-build-all-tar
          path: go-build-all.tar.gz

      - name: Upload combined artifact (zip)
        uses: actions/upload-artifact@v4
        with:
          name: go-build-all-zip
          path: go-build-all.zip

      - name: Upload per-OS archives
        if: hashFiles('per-os/*') != ''
        uses: actions/upload-artifact@v4
        with:
          name: go-build-per-os
          path: per-os/

  publish-release:
    name: Publish GitHub Release
    needs: aggregate-artifacts
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Download combined tar
        uses: actions/download-artifact@v5
        with:
          name: go-build-all-tar
          path: artifacts
      - name: Download combined zip
        uses: actions/download-artifact@v5
        with:
          name: go-build-all-zip
          path: artifacts
      - name: Download checksums
        uses: actions/download-artifact@v5
        with:
          name: go-build-all-checksums
          path: artifacts
      - name: Download per-OS archives
        uses: actions/download-artifact@v5
        with:
          name: go-build-per-os
          path: artifacts/per-os
        continue-on-error: true
      - name: Download SBOMs
        uses: actions/download-artifact@v5
        with:
          name: go-build-sboms
          path: artifacts/sboms
        continue-on-error: true
      - name: Download signatures
        uses: actions/download-artifact@v5
        with:
          name: go-build-signatures
          path: artifacts/signatures
        continue-on-error: true
      - name: Prepare release assets
        run: |
          set -euo pipefail
          ls -R artifacts | head -200
          find artifacts -type f -maxdepth 4 -exec cp {} . \;
          ls -l .
      - name: Create / Update Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            go-build-all.tar.gz
            go-build-all.zip
            go-build-all.tar.gz.sha256
            go-build-all.zip.sha256
            go-build-all.sbom.spdx.json
            go-build-all.tar.gz.sig
            go-build-all.zip.sig
            go-build-*.tar.gz
            go-build-*.zip
            go-build-*.tar.gz.sha256
            go-build-*.zip.sha256
            go-build-*.sbom.spdx.json
            go-build-*.sig
          draft: false
          prerelease: false
