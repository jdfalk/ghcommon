# file: .github/workflows/reusable-release.yml
# version: 1.1.0
# guid: reusable-release-2025-09-24-coordinator

name: Reusable Release Coordinator

on:
  workflow_call:
    inputs:
      release-type:
        description: "Release type (auto, major, minor, patch)"
        required: false
        type: string
        default: "auto"
      build-target:
        description: "Build target (all, go, python, rust, frontend, docker, protobuf)"
        required: false
        type: string
        default: "all"
      prerelease:
        description: "Create as prerelease"
        required: false
        type: boolean
        default: false
      draft:
        description: "Create as draft"
        required: false
        type: boolean
        default: false
      skip-language-detection:
        description: "Skip automatic language detection"
        required: false
        type: boolean
        default: false
      go-enabled:
        description: "Force enable Go builds"
        required: false
        type: boolean
        default: false
      python-enabled:
        description: "Force enable Python builds"
        required: false
        type: boolean
        default: false
      rust-enabled:
        description: "Force enable Rust builds"
        required: false
        type: boolean
        default: false
      frontend-enabled:
        description: "Force enable Frontend builds"
        required: false
        type: boolean
        default: false
      docker-enabled:
        description: "Force enable Docker builds"
        required: false
        type: boolean
        default: false
      protobuf-enabled:
        description: "Force enable Protobuf builds"
        required: false
        type: boolean
        default: false
    outputs:
      release-created:
        description: "Whether a release was created"
        value: ${{ jobs.build-status.outputs.release-created }}
      release-tag:
        description: "The created release tag"
        value: ${{ jobs.detect-languages.outputs.release-tag }}
      primary-language:
        description: "The detected primary language"
        value: ${{ jobs.detect-languages.outputs.primary-language }}

permissions:
  contents: write
  packages: write
  attestations: write
  id-token: write
  security-events: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Load unified configuration
  load-config:
    name: Load Repository Configuration
    runs-on: ubuntu-latest
    outputs:
      config: ${{ steps.load-config.outputs.config }}
      has-config: ${{ steps.load-config.outputs.has-config }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Load repository configuration
        id: load-config
        run: |
          config_file=".github/repository-config.yml"
          if [[ -f "$config_file" ]]; then
            echo "has-config=true" >> $GITHUB_OUTPUT
            # Convert YAML to JSON for easier parsing in other jobs
            python3 -c "
            import yaml, json
            with open('$config_file') as f:
                config = yaml.safe_load(f)
            print('config=' + json.dumps(config, separators=(',', ':')))
            " >> $GITHUB_OUTPUT
          else
            echo "has-config=false" >> $GITHUB_OUTPUT
            echo "config={}" >> $GITHUB_OUTPUT
          fi

  # Detect what languages/technologies are present
  detect-languages:
    name: Detect Project Languages
    runs-on: ubuntu-latest
    needs: [load-config]
    outputs:
      has-go: ${{ steps.detect.outputs.has-go }}
      has-python: ${{ steps.detect.outputs.has-python }}
      has-frontend: ${{ steps.detect.outputs.has-frontend }}
      has-docker: ${{ steps.detect.outputs.has-docker }}
      has-rust: ${{ steps.detect.outputs.has-rust }}
      protobuf-needed: ${{ steps.detect.outputs.protobuf-needed }}
      primary-language: ${{ steps.detect.outputs.primary-language }}
      go-matrix: ${{ steps.detect.outputs.go-matrix }}
      python-matrix: ${{ steps.detect.outputs.python-matrix }}
      frontend-matrix: ${{ steps.detect.outputs.frontend-matrix }}
      docker-matrix: ${{ steps.detect.outputs.docker-matrix }}
      rust-matrix: ${{ steps.detect.outputs.rust-matrix }}
      registry: ${{ steps.env-setup.outputs.registry }}
      image-name: ${{ steps.env-setup.outputs.image-name }}
      release-tag: ${{ steps.version.outputs.tag }}
      release-branch-strategy: ${{ steps.release-strategy.outputs.strategy }}
      auto-prerelease: ${{ steps.release-strategy.outputs.auto-prerelease }}
      auto-draft: ${{ steps.release-strategy.outputs.auto-draft }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup environment variables
        id: env-setup
        run: |
          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "image-name=${IMAGE_NAME}" >> $GITHUB_OUTPUT

      - name: Detect project languages and generate matrices
        id: detect
        run: |
          # Use input overrides if language detection is skipped
          if [[ "${{ inputs.skip-language-detection }}" == "true" ]]; then
            echo "has-go=${{ inputs.go-enabled }}" >> $GITHUB_OUTPUT
            echo "has-python=${{ inputs.python-enabled }}" >> $GITHUB_OUTPUT
            echo "has-rust=${{ inputs.rust-enabled }}" >> $GITHUB_OUTPUT
            echo "has-frontend=${{ inputs.frontend-enabled }}" >> $GITHUB_OUTPUT
            echo "has-docker=${{ inputs.docker-enabled }}" >> $GITHUB_OUTPUT
            echo "protobuf-needed=${{ inputs.protobuf-enabled }}" >> $GITHUB_OUTPUT
          else
            # Auto-detect languages
            has_go="false"
            has_python="false"
            has_rust="false"
            has_frontend="false"
            has_docker="false"
            protobuf_needed="false"
            primary_lang="unknown"

            # Go detection
            if [[ -f "go.mod" || -f "main.go" || -d "cmd" || -d "pkg" ]]; then
              has_go="true"
              primary_lang="go"
            fi

            # Python detection
            if [[ -f "setup.py" || -f "pyproject.toml" || -f "requirements.txt" || -f "poetry.lock" ]]; then
              has_python="true"
              [[ "$primary_lang" == "unknown" ]] && primary_lang="python"
            fi

            # Rust detection
            if [[ -f "Cargo.toml" || -f "Cargo.lock" ]]; then
              has_rust="true"
              [[ "$primary_lang" == "unknown" ]] && primary_lang="rust"
            fi

            # Frontend detection
            if [[ -f "package.json" || -d "webui" || -d "frontend" || -d "ui" ]]; then
              has_frontend="true"
              [[ "$primary_lang" == "unknown" ]] && primary_lang="frontend"
            fi

            # Docker detection
            if [[ -f "Dockerfile" || -f "docker-compose.yml" || -f "docker-compose.yaml" ]]; then
              has_docker="true"
            fi

            # Protobuf detection
            if [[ -f "buf.yaml" || -f "buf.gen.yaml" || -n "$(find . -name '*.proto' -type f 2>/dev/null | head -1)" ]]; then
              protobuf_needed="true"
            fi

            echo "has-go=$has_go" >> $GITHUB_OUTPUT
            echo "has-python=$has_python" >> $GITHUB_OUTPUT
            echo "has-rust=$has_rust" >> $GITHUB_OUTPUT
            echo "has-frontend=$has_frontend" >> $GITHUB_OUTPUT
            echo "has-docker=$has_docker" >> $GITHUB_OUTPUT
            echo "protobuf-needed=$protobuf_needed" >> $GITHUB_OUTPUT
            echo "primary-language=$primary_lang" >> $GITHUB_OUTPUT
          fi

          # Generate build matrices (simplified for reusable workflow)
          echo 'go-matrix={"go-version":["1.22","1.23","1.24"],"os":["ubuntu-latest","macos-latest"]}' >> $GITHUB_OUTPUT
          echo 'python-matrix={"python-version":["3.11","3.12","3.13"],"os":["ubuntu-latest","macos-latest"]}' >> $GITHUB_OUTPUT
          echo 'rust-matrix={"rust-version":["stable","beta"],"os":["ubuntu-latest","macos-latest"]}' >> $GITHUB_OUTPUT
          echo 'frontend-matrix={"node-version":["18","20","22"],"os":["ubuntu-latest"]}' >> $GITHUB_OUTPUT
          echo 'docker-matrix={"platform":["linux/amd64","linux/arm64"]}' >> $GITHUB_OUTPUT

      - name: Determine release strategy based on branch
        id: release-strategy
        run: |
          BRANCH_NAME="${{ github.ref_name }}"

          # Determine release strategy based on branch and manual inputs
          if [[ "$BRANCH_NAME" == "main" ]]; then
            STRATEGY="stable"
            AUTO_PRERELEASE="false"
            AUTO_DRAFT="false"
          elif [[ "$BRANCH_NAME" == "develop" ]]; then
            STRATEGY="prerelease"
            AUTO_PRERELEASE="true"
            AUTO_DRAFT="false"
          else
            STRATEGY="draft"
            AUTO_PRERELEASE="false"
            AUTO_DRAFT="true"
          fi

          # Override with manual inputs if provided
          if [[ "${{ inputs.prerelease }}" == "true" ]]; then
            AUTO_PRERELEASE="true"
          fi
          if [[ "${{ inputs.draft }}" == "true" ]]; then
            AUTO_DRAFT="true"
          fi

          echo "strategy=$STRATEGY" >> $GITHUB_OUTPUT
          echo "auto-prerelease=$AUTO_PRERELEASE" >> $GITHUB_OUTPUT
          echo "auto-draft=$AUTO_DRAFT" >> $GITHUB_OUTPUT

          echo "ðŸ”„ Release strategy for branch '$BRANCH_NAME': $STRATEGY"
          echo "ðŸ“‹ Auto-prerelease: $AUTO_PRERELEASE"
          echo "ðŸ“‹ Auto-draft: $AUTO_DRAFT"

      - name: Generate semantic release version
        id: version
        run: |
          # Get the latest tag to determine version increment
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Extract version numbers (remove 'v' prefix and any suffix)
          VERSION_CORE=$(echo "$LATEST_TAG" | sed 's/^v//' | sed 's/-.*//')
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_CORE"

          # Default to 0 if any version component is missing
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}

          echo "Current version: $MAJOR.$MINOR.$PATCH"

          # Determine version increment based on release type and branch
          RELEASE_TYPE="${{ inputs.release-type || 'auto' }}"
          BRANCH_NAME="${{ github.ref_name }}"

          if [[ "$RELEASE_TYPE" == "major" ]]; then
            NEW_MAJOR=$((MAJOR + 1))
            NEW_MINOR=0
            NEW_PATCH=0
          elif [[ "$RELEASE_TYPE" == "minor" ]]; then
            NEW_MAJOR=$MAJOR
            NEW_MINOR=$((MINOR + 1))
            NEW_PATCH=0
          elif [[ "$RELEASE_TYPE" == "patch" ]]; then
            NEW_MAJOR=$MAJOR
            NEW_MINOR=$MINOR
            NEW_PATCH=$((PATCH + 1))
          else
            # Auto versioning based on branch and commits
            if [[ "$BRANCH_NAME" == "main" ]]; then
              # Stable release: increment patch
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$MINOR
              NEW_PATCH=$((PATCH + 1))
            elif [[ "$BRANCH_NAME" == "develop" ]]; then
              # Pre-release: increment minor
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$((MINOR + 1))
              NEW_PATCH=0
            else
              # Draft/feature branch: increment patch with branch suffix
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$MINOR
              NEW_PATCH=$((PATCH + 1))
            fi
          fi

          # Build version string with appropriate suffixes
          if [[ "${{ steps.release-strategy.outputs.auto-prerelease }}" == "true" ]]; then
            if [[ "$BRANCH_NAME" == "develop" ]]; then
              VERSION_TAG="v${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}-beta.$(date +%Y%m%d%H%M)"
            else
              VERSION_TAG="v${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}-alpha.$(date +%Y%m%d%H%M)"
            fi
          elif [[ "${{ steps.release-strategy.outputs.auto-draft }}" == "true" ]]; then
            SAFE_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9]/-/g')
            VERSION_TAG="v${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}-${SAFE_BRANCH}.$(date +%Y%m%d%H%M)"
          else
            VERSION_TAG="v${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}"
          fi

          echo "Generated version tag: $VERSION_TAG"
          echo "tag=$VERSION_TAG" >> $GITHUB_OUTPUT

  # Protocol Buffer Generation (if needed)
  build-protobuf:
    name: Generate Protocol Buffers
    needs: [detect-languages]
    if: needs.detect-languages.outputs.protobuf-needed == 'true'
    uses: ./.github/workflows/release-protobuf.yml
    secrets: inherit

  # Go Build
  build-go:
    name: Build Go Components
    needs: [detect-languages, build-protobuf]
    if: |
      always() &&
      needs.detect-languages.outputs.has-go == 'true' &&
      (inputs.build-target == 'all' || inputs.build-target == 'go')
    uses: ./.github/workflows/release-go.yml
    with:
      go-matrix: ${{ needs.detect-languages.outputs.go-matrix }}
      protobuf-artifacts: ${{ needs.detect-languages.outputs.protobuf-needed }}
    secrets: inherit

  # Python Build
  build-python:
    name: Build Python Components
    needs: [detect-languages, build-protobuf]
    if: |
      always() &&
      needs.detect-languages.outputs.has-python == 'true' &&
      (inputs.build-target == 'all' || inputs.build-target == 'python')
    uses: ./.github/workflows/release-python.yml
    with:
      python-matrix: ${{ needs.detect-languages.outputs.python-matrix }}
      protobuf-artifacts: ${{ needs.detect-languages.outputs.protobuf-needed }}
    secrets: inherit

  # Rust Build
  build-rust:
    name: Build Rust Components
    needs: [detect-languages, build-protobuf]
    if: |
      always() &&
      needs.detect-languages.outputs.has-rust == 'true' &&
      (inputs.build-target == 'all' || inputs.build-target == 'rust')
    uses: ./.github/workflows/release-rust.yml
    with:
      protobuf-artifacts: ${{ needs.detect-languages.outputs.protobuf-needed }}
    secrets: inherit

  # Frontend Build
  build-frontend:
    name: Build Frontend Components
    needs: [detect-languages]
    if: |
      always() &&
      needs.detect-languages.outputs.has-frontend == 'true' &&
      (inputs.build-target == 'all' || inputs.build-target == 'frontend')
    uses: ./.github/workflows/release-frontend.yml
    with:
      frontend-matrix: ${{ needs.detect-languages.outputs.frontend-matrix }}
    secrets: inherit

  # Docker Build
  build-docker:
    name: Build Docker Images
    needs: [detect-languages, build-go, build-python, build-rust]
    if: |
      always() &&
      needs.detect-languages.outputs.has-docker == 'true' &&
      (inputs.build-target == 'all' || inputs.build-target == 'docker')
    uses: ./.github/workflows/release-docker.yml
    with:
      docker-matrix: ${{ needs.detect-languages.outputs.docker-matrix }}
      registry: ${{ needs.detect-languages.outputs.registry }}
      image-name: ${{ needs.detect-languages.outputs.image-name }}
    secrets: inherit

  # Create GitHub Release
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [detect-languages, build-go, build-python, build-rust, build-frontend, build-docker]
    if: |
      always() &&
      !failure() &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    outputs:
      version: ${{ steps.version.outputs.version }}
      release-url: ${{ steps.release.outputs.upload_url }}
      release-id: ${{ steps.release.outputs.id }}
      release-created: ${{ steps.check-release.outputs.created }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Get version
        id: version
        run: |
          VERSION="${{ needs.detect-languages.outputs.release-tag }}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          # Generate changelog based on conventional commits and branch strategy
          echo "## ðŸš€ What's Changed" > changelog.md
          echo "" >> changelog.md

          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [[ -n "$LAST_TAG" ]]; then
            echo "### ðŸ“‹ Commits since $LAST_TAG:" >> changelog.md
            git log ${LAST_TAG}..HEAD --oneline --format="- %s (%h)" >> changelog.md
          else
            echo "### ðŸ“‹ Initial Release Commits:" >> changelog.md
            git log --oneline --format="- %s (%h)" >> changelog.md
          fi

          echo "" >> changelog.md
          echo "### ðŸŽ¯ Release Information" >> changelog.md
          echo "- **Branch:** ${{ github.ref_name }}" >> changelog.md
          echo "- **Release Type:** ${{ needs.detect-languages.outputs.release-branch-strategy }}" >> changelog.md
          echo "- **Primary Language:** ${{ needs.detect-languages.outputs.primary-language }}" >> changelog.md

          if [[ "${{ needs.detect-languages.outputs.auto-prerelease }}" == "true" ]]; then
            echo "" >> changelog.md
            echo "âš ï¸ **This is a pre-release version** - use for testing purposes." >> changelog.md
          fi

          if [[ "${{ needs.detect-languages.outputs.auto-draft }}" == "true" ]]; then
            echo "" >> changelog.md
            echo "ðŸ“ **This is a draft release** - review before making public." >> changelog.md
          fi

      - name: Download all build artifacts
        uses: actions/download-artifact@v5
        with:
          path: ./artifacts
          merge-multiple: true

      - name: Package and organize release artifacts
        id: package-artifacts
        run: |
          echo "ðŸ“¦ Organizing and packaging release artifacts..."

          # Create release directory structure
          mkdir -p release-assets/{sdks,binaries,packages,documentation}

          # Move and organize SDK packages
          if find ./artifacts -name "*-sdk.*" -type f | grep -q .; then
            echo "Moving SDK packages..."
            find ./artifacts -name "*-sdk.*" -type f -exec mv {} release-assets/sdks/ \;
            ls -la release-assets/sdks/
          fi

          # Move documentation packages
          if find ./artifacts -name "*docs.*" -type f | grep -q .; then
            echo "Moving documentation packages..."
            find ./artifacts -name "*docs.*" -type f -exec mv {} release-assets/documentation/ \;
          fi

          # Move binary files (executables)
          if find ./artifacts -name "*.exe" -o -name "*-linux-*" -o -name "*-darwin-*" -o -name "*-windows-*" | grep -q .; then
            echo "Moving binary packages..."
            find ./artifacts \( -name "*.exe" -o -name "*-linux-*" -o -name "*-darwin-*" -o -name "*-windows-*" \) -type f -exec mv {} release-assets/binaries/ \;
          fi

          # Move other packages (wheels, containers, etc.)
          if find ./artifacts -name "*.whl" -o -name "*.tar.gz" -o -name "*.zip" | grep -q .; then
            echo "Moving other packages..."
            find ./artifacts \( -name "*.whl" -o -name "*.tar.gz" -o -name "*.zip" \) -type f -exec mv {} release-assets/packages/ \;
          fi

          # Create a comprehensive release manifest
          echo "Creating release manifest..."
          {
            echo "# Release Manifest - ${{ steps.version.outputs.version }}"
            echo "Generated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""
            echo "## SDK Packages"
            if [ -d "release-assets/sdks" ] && [ "$(ls -A release-assets/sdks 2>/dev/null)" ]; then
              ls -la release-assets/sdks/ | tail -n +2 | awk '{print "- " $9 " (" $5 " bytes)"}'
            else
              echo "- No SDK packages"
            fi
            echo ""
            echo "## Documentation"
            if [ -d "release-assets/documentation" ] && [ "$(ls -A release-assets/documentation 2>/dev/null)" ]; then
              ls -la release-assets/documentation/ | tail -n +2 | awk '{print "- " $9 " (" $5 " bytes)"}'
            else
              echo "- No documentation packages"
            fi
            echo ""
            echo "## Binaries"
            if [ -d "release-assets/binaries" ] && [ "$(ls -A release-assets/binaries 2>/dev/null)" ]; then
              ls -la release-assets/binaries/ | tail -n +2 | awk '{print "- " $9 " (" $5 " bytes)"}'
            else
              echo "- No binary packages"
            fi
            echo ""
            echo "## Other Packages"
            if [ -d "release-assets/packages" ] && [ "$(ls -A release-assets/packages 2>/dev/null)" ]; then
              ls -la release-assets/packages/ | tail -n +2 | awk '{print "- " $9 " (" $5 " bytes)"}'
            else
              echo "- No other packages"
            fi
          } > release-assets/MANIFEST.md

          # Show summary
          echo "Release assets organized:"
          find release-assets -type f | wc -l | xargs echo "Total files:"
          du -sh release-assets/ | awk '{print "Total size: " $1}'

          # Set output indicating packaging completion
          echo "packaging-complete=true" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        id: release
        uses: softprops/action-gh-release@v2
        if: github.event_name != 'pull_request'
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: ${{ steps.version.outputs.version }}
          body: |
            $(cat changelog.md)

            ## ðŸ“¦ Release Assets

            This release includes organized packages for easy consumption:

            ### SDKs
            - **Go SDK**: `gcommon-go-sdk.tar.gz` / `gcommon-go-sdk.zip`
            - **Python SDK**: `gcommon-python-sdk.tar.gz` / `gcommon-python-sdk.zip`

            ### Documentation
            - **API Documentation**: `gcommon-docs.tar.gz` / `gcommon-docs.zip`

            See `MANIFEST.md` for a complete list of all assets and their sizes.

            ---
            *Generated automatically from commit ${{ github.sha }}*
          draft: ${{ needs.detect-languages.outputs.auto-draft }}
          prerelease: ${{ needs.detect-languages.outputs.auto-prerelease }}
          files: |
            release-assets/**/*
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check release created
        id: check-release
        run: |
          if [ "${{ steps.release.outcome }}" = "success" ]; then
            echo "created=true" >> $GITHUB_OUTPUT
          else
            echo "created=false" >> $GITHUB_OUTPUT
          fi
          if [[ "${{ steps.release.outcome }}" == "success" ]]; then
            echo "release-created=true" >> $GITHUB_OUTPUT
          else
            echo "release-created=false" >> $GITHUB_OUTPUT
          fi

  # Final status check
  build-status:
    name: Release Status Summary
    runs-on: ubuntu-latest
    needs: [detect-languages, build-go, build-python, build-rust, build-frontend, build-docker, create-release]
    if: always()
    outputs:
      release-created: ${{ needs.create-release.outputs.release-created || 'false' }}
    steps:
      - name: Generate release summary
        run: |
          echo "# ðŸš€ Release Build Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Project Type:** ${{ needs.detect-languages.outputs.primary-language }}" >> $GITHUB_STEP_SUMMARY
          echo "**Build Target:** ${{ inputs.build-target }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release Tag:** ${{ needs.detect-languages.outputs.release-tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release Strategy:** ${{ needs.detect-languages.outputs.release-branch-strategy }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Go | ${{ needs.build-go.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Python | ${{ needs.build-python.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Rust | ${{ needs.build-rust.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | ${{ needs.build-frontend.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker | ${{ needs.build-docker.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Release | ${{ needs.create-release.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY

          # Check for any failures
          if [[ "${{ needs.build-go.result }}" == "failure" ||
                "${{ needs.build-python.result }}" == "failure" ||
                "${{ needs.build-rust.result }}" == "failure" ||
                "${{ needs.build-frontend.result }}" == "failure" ||
                "${{ needs.build-docker.result }}" == "failure" ||
                "${{ needs.create-release.result }}" == "failure" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âŒ **Some components failed**" >> $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âœ… **All components completed successfully**" >> $GITHUB_STEP_SUMMARY
            if [[ "${{ needs.create-release.outputs.release-created }}" == "true" ]]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "ðŸŽ‰ **Release created: ${{ needs.detect-languages.outputs.release-tag }}**" >> $GITHUB_STEP_SUMMARY
              if [[ "${{ needs.detect-languages.outputs.auto-prerelease }}" == "true" ]]; then
                echo "âš ï¸ **Pre-release** - for testing purposes" >> $GITHUB_STEP_SUMMARY
              elif [[ "${{ needs.detect-languages.outputs.auto-draft }}" == "true" ]]; then
                echo "ðŸ“ **Draft release** - review before publishing" >> $GITHUB_STEP_SUMMARY
              else
                echo "ðŸš€ **Stable release** - ready for production" >> $GITHUB_STEP_SUMMARY
              fi
            fi
          fi
