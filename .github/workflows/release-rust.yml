# file: .github/workflows/release-rust.yml
# version: 1.0.0
# guid: b2c3d4e5-f6a7-8b9c-0d1e-2f3a4b5c6d7e

name: Rust Release

on:
  workflow_call:
    inputs:
      release_type:
        description: "Release type"
        required: false
        default: "auto"
        type: string
      prerelease:
        description: "Is this a prerelease?"
        required: false
        default: false
        type: boolean
      draft:
        description: "Create as draft?"
        required: false
        default: false
        type: boolean
    outputs:
      version:
        description: "The released version"
        value: ${{ jobs.release.outputs.version }}
      tag:
        description: "The release tag"
        value: ${{ jobs.release.outputs.tag }}

permissions:
  contents: write
  packages: write
  attestations: write
  id-token: write

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  determine-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      changelog: ${{ steps.version.outputs.changelog }}
      should-release: ${{ steps.version.outputs.should-release }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js for semantic-release
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Create package.json for semantic-release
        run: |
          cat > package.json << EOF
          {
            "name": "rust-project",
            "version": "0.0.0-development",
            "private": true,
            "devDependencies": {
              "@semantic-release/changelog": "^6.0.3",
              "@semantic-release/git": "^10.0.1",
              "@semantic-release/github": "^9.2.6",
              "@semantic-release/exec": "^6.0.3",
              "semantic-release": "^22.0.12",
              "conventional-changelog-conventionalcommits": "^7.0.2"
            }
          }
          EOF

      - name: Create semantic-release config
        run: |
          cat > .releaserc.json << EOF
          {
            "branches": ["main"],
            "plugins": [
              [
                "@semantic-release/commit-analyzer",
                {
                  "preset": "conventionalcommits",
                  "releaseRules": [
                    {"type": "feat", "release": "minor"},
                    {"type": "fix", "release": "patch"},
                    {"type": "perf", "release": "patch"},
                    {"type": "revert", "release": "patch"},
                    {"type": "docs", "release": false},
                    {"type": "style", "release": false},
                    {"type": "chore", "release": false},
                    {"type": "refactor", "release": "patch"},
                    {"type": "test", "release": false},
                    {"type": "build", "release": false},
                    {"type": "ci", "release": false},
                    {"breaking": true, "release": "major"}
                  ]
                }
              ],
              [
                "@semantic-release/release-notes-generator",
                {
                  "preset": "conventionalcommits"
                }
              ],
              [
                "@semantic-release/exec",
                {
                  "prepareCmd": "sed -i 's/^version = \".*\"/version = \"\${nextRelease.version}\"/' Cargo.toml"
                }
              ],
              [
                "@semantic-release/changelog",
                {
                  "changelogFile": "CHANGELOG.md"
                }
              ],
              [
                "@semantic-release/git",
                {
                  "assets": ["Cargo.toml", "CHANGELOG.md"],
                  "message": "chore(release): \${nextRelease.version} [skip ci]\n\n\${nextRelease.notes}"
                }
              ],
              [
                "@semantic-release/github",
                {
                  "assets": [
                    "./releases/*.tar.gz",
                    "./releases/*.zip"
                  ]
                }
              ]
            ]
          }
          EOF

      - name: Install dependencies
        run: npm install

      - name: Determine next version
        id: version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MANUAL_RELEASE_TYPE: ${{ inputs.release_type }}
        run: |
          if [[ "$MANUAL_RELEASE_TYPE" != "auto" && "$MANUAL_RELEASE_TYPE" != "" ]]; then
            echo "Manual release type specified: $MANUAL_RELEASE_TYPE"
            CURRENT_VERSION=$(grep '^version = ' Cargo.toml | sed 's/version = "\(.*\)"/\1/')
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}

            case "$MANUAL_RELEASE_TYPE" in
              "major")
                NEW_VERSION="$((MAJOR + 1)).0.0"
                ;;
              "minor")
                NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
                ;;
              "patch")
                NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
                ;;
            esac

            echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "changelog=Manual $MANUAL_RELEASE_TYPE release" >> $GITHUB_OUTPUT
          else
            # Run semantic-release in dry-run mode to determine version
            npx semantic-release --dry-run > release_output.log 2>&1 || true

            if grep -q "The next release version is" release_output.log; then
              NEW_VERSION=$(grep "The next release version is" release_output.log | sed 's/.*The next release version is \([0-9.]*\).*/\1/')
              echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
              echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
              echo "should-release=true" >> $GITHUB_OUTPUT

              # Extract changelog
              CHANGELOG=$(npx semantic-release --dry-run 2>&1 | grep -A 100 "Release note for version" | tail -n +2 | head -n -1 || echo "Automated release")
              echo "changelog<<EOF" >> $GITHUB_OUTPUT
              echo "$CHANGELOG" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            else
              echo "No release needed based on conventional commits"
              echo "should-release=false" >> $GITHUB_OUTPUT
            fi
          fi

  build:
    name: Build for ${{ matrix.target }}
    runs-on: ${{ matrix.os }}
    needs: determine-version
    if: needs.determine-version.outputs.should-release == 'true'
    strategy:
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            name: linux-amd64
          - target: x86_64-unknown-linux-musl
            os: ubuntu-latest
            name: linux-amd64-musl
          - target: aarch64-unknown-linux-gnu
            os: ubuntu-latest
            name: linux-arm64
          - target: x86_64-apple-darwin
            os: macos-latest
            name: darwin-amd64
          - target: aarch64-apple-darwin
            os: macos-latest
            name: darwin-arm64
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            name: windows-amd64
            ext: .exe

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cross-compilation tools (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu gcc-x86-64-linux-gnu musl-tools

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ matrix.target }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-${{ matrix.target }}-
            ${{ runner.os }}-cargo-

      - name: Update Cargo.toml version
        shell: bash
        run: |
          sed -i 's/^version = ".*"/version = "${{ needs.determine-version.outputs.version }}"/' Cargo.toml

      - name: Build binary
        env:
          CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER: aarch64-linux-gnu-gcc
        run: |
          cargo build --release --target ${{ matrix.target }}

      - name: Get binary name from Cargo.toml
        id: binary-name
        shell: bash
        run: |
          # Extract binary name from Cargo.toml
          if grep -q "^\[\[bin\]\]" Cargo.toml; then
            BINARY_NAME=$(awk '/\[\[bin\]\]/{flag=1; next} flag && /^name =/{gsub(/[" ]/, "", $3); print $3; exit}' Cargo.toml)
          else
            # Fall back to package name
            BINARY_NAME=$(grep '^name = ' Cargo.toml | head -1 | sed 's/name = "\(.*\)"/\1/')
          fi
          echo "binary_name=$BINARY_NAME" >> $GITHUB_OUTPUT
          echo "Binary name: $BINARY_NAME"

      - name: Create archive (Unix)
        if: matrix.os != 'windows-latest'
        run: |
          mkdir -p releases
          tar -czf releases/${{ steps.binary-name.outputs.binary_name }}-${{ needs.determine-version.outputs.version }}-${{ matrix.name }}.tar.gz \
            -C target/${{ matrix.target }}/release ${{ steps.binary-name.outputs.binary_name }}

      - name: Create archive (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          mkdir releases
          Compress-Archive -Path target/${{ matrix.target }}/release/${{ steps.binary-name.outputs.binary_name }}.exe -DestinationPath releases/${{ steps.binary-name.outputs.binary_name }}-${{ needs.determine-version.outputs.version }}-${{ matrix.name }}.zip

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.binary-name.outputs.binary_name }}-${{ matrix.name }}
          path: releases/*

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [determine-version, build]
    if: needs.determine-version.outputs.should-release == 'true'
    outputs:
      version: ${{ needs.determine-version.outputs.version }}
      tag: ${{ needs.determine-version.outputs.tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js for semantic-release
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./releases
          merge-multiple: true

      - name: List artifacts
        run: ls -la ./releases/

      - name: Create package.json for semantic-release
        run: |
          cat > package.json << EOF
          {
            "name": "rust-project",
            "version": "0.0.0-development",
            "private": true,
            "devDependencies": {
              "@semantic-release/changelog": "^6.0.3",
              "@semantic-release/git": "^10.0.1",
              "@semantic-release/github": "^9.2.6",
              "@semantic-release/exec": "^6.0.3",
              "semantic-release": "^22.0.12",
              "conventional-changelog-conventionalcommits": "^7.0.2"
            }
          }
          EOF

      - name: Create semantic-release config
        run: |
          cat > .releaserc.json << EOF
          {
            "branches": ["main"],
            "plugins": [
              [
                "@semantic-release/commit-analyzer",
                {
                  "preset": "conventionalcommits",
                  "releaseRules": [
                    {"type": "feat", "release": "minor"},
                    {"type": "fix", "release": "patch"},
                    {"type": "perf", "release": "patch"},
                    {"type": "revert", "release": "patch"},
                    {"type": "docs", "release": false},
                    {"type": "style", "release": false},
                    {"type": "chore", "release": false},
                    {"type": "refactor", "release": "patch"},
                    {"type": "test", "release": false},
                    {"type": "build", "release": false},
                    {"type": "ci", "release": false},
                    {"breaking": true, "release": "major"}
                  ]
                }
              ],
              [
                "@semantic-release/release-notes-generator",
                {
                  "preset": "conventionalcommits"
                }
              ],
              [
                "@semantic-release/exec",
                {
                  "prepareCmd": "sed -i 's/^version = \".*\"/version = \"\${nextRelease.version}\"/' Cargo.toml"
                }
              ],
              [
                "@semantic-release/changelog",
                {
                  "changelogFile": "CHANGELOG.md"
                }
              ],
              [
                "@semantic-release/git",
                {
                  "assets": ["Cargo.toml", "CHANGELOG.md"],
                  "message": "chore(release): \${nextRelease.version} [skip ci]\n\n\${nextRelease.notes}"
                }
              ],
              [
                "@semantic-release/github",
                {
                  "assets": [
                    "./releases/*.tar.gz",
                    "./releases/*.zip"
                  ]
                }
              ]
            ]
          }
          EOF

      - name: Install dependencies
        run: npm install

      - name: Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [[ "${{ inputs.release_type }}" != "auto" && "${{ inputs.release_type }}" != "" ]]; then
            # Manual release - create GitHub release directly
            gh release create "${{ needs.determine-version.outputs.tag }}" \
              --title "Release ${{ needs.determine-version.outputs.version }}" \
              --notes "${{ needs.determine-version.outputs.changelog }}" \
              ${{ inputs.prerelease && '--prerelease' || '' }} \
              ${{ inputs.draft && '--draft' || '' }} \
              ./releases/*
          else
            # Use semantic-release for automated releases
            npx semantic-release
          fi

  update-homebrew:
    name: Update Homebrew Formula
    runs-on: ubuntu-latest
    needs: [determine-version, release]
    if: needs.determine-version.outputs.should-release == 'true' && !inputs.prerelease
    steps:
      - name: Update Homebrew formula
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Homebrew formula update would go here"
          echo "Version: ${{ needs.determine-version.outputs.version }}"
          echo "Tag: ${{ needs.determine-version.outputs.tag }}"
          # This would typically update a homebrew-tap repository
          # or submit a PR to homebrew/homebrew-core
