# file: .github/workflows/reusable-protobuf.yml
# version: 1.1.1
# guid: f1e2d3c4-b5a6-9788-c0d1-2e3f4a5b6c7d

name: Reusable Protobuf Generation

on:
  workflow_call:
    inputs:
      config-path:
        description: "Path to the repository configuration file"
        required: false
        type: string
        default: ".github/repository-config.yml"
      protobuf-path:
        description: "Path to protobuf source files"
        required: false
        type: string
        default: "proto"
      output-path:
        description: "Output path for generated code"
        required: false
        type: string
        default: "sdks"
      generate-docs:
        description: "Generate protobuf documentation"
        required: false
        type: boolean
        default: false
      skip-post-processing:
        description: "Skip post-generation processing scripts"
        required: false
        type: boolean
        default: false
    outputs:
      artifacts-available:
        description: "Whether protobuf artifacts were generated"
        value: ${{ jobs.generate-protobuf.outputs.artifacts-available }}
      go-files-generated:
        description: "Number of Go files generated"
        value: ${{ jobs.generate-protobuf.outputs.go-files-generated }}
      python-files-generated:
        description: "Number of Python files generated"
        value: ${{ jobs.generate-protobuf.outputs.python-files-generated }}
      docs-generated:
        description: "Whether documentation was generated"
        value: ${{ jobs.generate-protobuf.outputs.docs-generated }}

permissions:
  contents: read

jobs:
  load-config:
    name: Load Configuration
    runs-on: ubuntu-latest
    outputs:
      config-loaded: ${{ steps.load-config.outputs.config-loaded }}
      protobuf-enabled: ${{ steps.parse-config.outputs.protobuf-enabled }}
      go-enabled: ${{ steps.parse-config.outputs.go-enabled }}
      python-enabled: ${{ steps.parse-config.outputs.python-enabled }}
      rust-enabled: ${{ steps.parse-config.outputs.rust-enabled }}
      protobuf-config: ${{ steps.parse-config.outputs.protobuf-config }}
      buf-version: ${{ steps.parse-config.outputs.buf-version }}
      protoc-version: ${{ steps.parse-config.outputs.protoc-version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Load repository configuration
        id: load-config
        env:
          CONFIG_PATH: ${{ inputs.config-path }}
        run: |
          if [ -f "$CONFIG_PATH" ]; then
            printf 'config-loaded=true\n' >> "$GITHUB_OUTPUT"
            echo "Configuration file found: $CONFIG_PATH"
          else
            printf 'config-loaded=false\n' >> "$GITHUB_OUTPUT"
            echo "Configuration file not found: $CONFIG_PATH"
            echo "Using default configuration"
          fi

      - name: Parse configuration
        id: parse-config
        env:
          CONFIG_PATH: ${{ inputs.config-path }}
        run: |
          python3 - <<'PY'
          from __future__ import annotations

          import json
          import os
          from pathlib import Path

          import yaml

          config_path = Path(os.environ["CONFIG_PATH"])

          config = {
              "languages": {
                  "go": {"enabled": False},
                  "python": {"enabled": False},
                  "rust": {"enabled": False},
              },
              "protobuf": {
                  "enabled": False,
                  "buf_version": "1.56.0",
                  "protoc_version": "28.2",
                  "source_path": "proto",
                  "output_path": "sdks",
                  "generate_docs": False,
              },
          }

          if config_path.exists():
              try:
                  with config_path.open("r", encoding="utf-8") as handle:
                      loaded_config = yaml.safe_load(handle)
                  if loaded_config:
                      config.update(loaded_config)
              except Exception as exc:  # pylint: disable=broad-except
                  print(f"Error loading config: {exc}")

          languages = config.get("languages", {})
          protobuf = config.get("protobuf", {})

          outputs = {
              "protobuf-enabled": str(protobuf.get("enabled", False)).lower(),
              "go-enabled": str(languages.get("go", {}).get("enabled", False)).lower(),
              "python-enabled": str(languages.get("python", {}).get("enabled", False)).lower(),
              "rust-enabled": str(languages.get("rust", {}).get("enabled", False)).lower(),
              "buf-version": protobuf.get("buf_version", "1.56.0"),
              "protoc-version": protobuf.get("protoc_version", "28.2"),
              "protobuf-config": json.dumps(protobuf),
          }

          output_path = Path(os.environ["GITHUB_OUTPUT"])
          with output_path.open("a", encoding="utf-8") as handle:
              for key, value in outputs.items():
                  handle.write(f"{key}={value}\n")
          PY

  generate-protobuf:
    name: Generate Protobuf Code
    runs-on: ubuntu-latest
    needs: [load-config]
    if: needs.load-config.outputs.protobuf-enabled == 'true'
    outputs:
      artifacts-available: ${{ steps.check-artifacts.outputs.artifacts-available }}
      go-files-generated: ${{ steps.check-artifacts.outputs.go-files-generated }}
      python-files-generated: ${{ steps.check-artifacts.outputs.python-files-generated }}
      docs-generated: ${{ steps.check-artifacts.outputs.docs-generated }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Go
        if: needs.load-config.outputs.go-enabled == 'true'
        uses: actions/setup-go@v6
        with:
          go-version: "1.23"
          cache: false

      - name: Set up Python
        if: needs.load-config.outputs.python-enabled == 'true'
        uses: actions/setup-python@v6
        with:
          python-version: "3.13"

      - name: Set up Rust
        if: needs.load-config.outputs.rust-enabled == 'true'
        uses: dtolnay/rust-toolchain@stable

      - name: Install Protocol Buffers Compiler (protoc)
        run: |
          echo "Installing protoc version ${{ needs.load-config.outputs.protoc-version }}..."
          PROTOC_VERSION="${{ needs.load-config.outputs.protoc-version }}"
          curl -LO "https://github.com/protocolbuffers/protobuf/releases/download/v${PROTOC_VERSION}/protoc-${PROTOC_VERSION}-linux-x86_64.zip"
          unzip -q protoc-${PROTOC_VERSION}-linux-x86_64.zip -d protoc
          sudo mv protoc/bin/protoc /usr/local/bin/
          sudo mv protoc/include/* /usr/local/include/
          sudo chmod +x /usr/local/bin/protoc
          rm -rf protoc protoc-${PROTOC_VERSION}-linux-x86_64.zip

          # Verify installation
          protoc --version

      - name: Set up Buf
        uses: bufbuild/buf-setup-action@v1
        with:
          version: ${{ needs.load-config.outputs.buf-version }}
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Go protobuf plugins
        if: needs.load-config.outputs.go-enabled == 'true'
        run: |
          echo "Installing Go protobuf plugins..."
          go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
          go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest

          # Add Go bin to PATH
          echo "$(go env GOPATH)/bin" >> "$GITHUB_PATH"

          # Verify installations
          which protoc-gen-go
          which protoc-gen-go-grpc
          protoc-gen-go --version
          protoc-gen-go-grpc --version

      - name: Install Python protobuf plugins
        if: needs.load-config.outputs.python-enabled == 'true'
        run: |
          echo "Installing Python protobuf plugins..."
          python -m pip install --upgrade pip
          python -m pip install grpcio-tools mypy-protobuf

          # Verify installations
          python -c "import grpc_tools.protoc; print('grpc_tools.protoc available')"
          python -c "import mypy_protobuf; print('mypy-protobuf available')"

      - name: Install Rust protobuf plugins
        if: needs.load-config.outputs.rust-enabled == 'true'
        run: |
          echo "Installing Rust protobuf plugins..."
          cargo install protobuf-codegen

          # Add cargo bin to PATH
          echo "$HOME/.cargo/bin" >> "$GITHUB_PATH"

      - name: Validate protobuf setup
        run: |
          echo "=== Protobuf Environment Validation ==="
          echo "Working directory: $(pwd)"
          echo "Protobuf source path: ${{ inputs.protobuf-path }}"
          echo "Output path: ${{ inputs.output-path }}"

          # Check for required files
          echo "buf.yaml exists: $(test -f buf.yaml && echo 'yes' || echo 'no')"
          echo "buf.gen.yaml exists: $(test -f buf.gen.yaml && echo 'yes' || echo 'no')"

          # List protobuf files
          if [ -d "${{ inputs.protobuf-path }}" ]; then
            echo "Found protobuf files:"
            find "${{ inputs.protobuf-path }}" -name "*.proto" | head -10
          else
            echo "No protobuf source directory found"
          fi

          # Tool versions
          echo "Tool versions:"
          protoc --version
          buf --version

      - name: Lint protobuf files
        run: |
          if [ -f buf.yaml ]; then
            echo "Linting protobuf files..."
            buf lint
          else
            echo "No buf.yaml found, skipping lint"
          fi

      - name: Generate protobuf code
        run: |
          if [ -f buf.gen.yaml ]; then
            echo "Generating protobuf code with buf..."
            cat buf.gen.yaml
            echo ""
            buf generate
          else
            echo "No buf.gen.yaml found, cannot generate code"
            exit 1
          fi

      - name: Create protobuf SDK packages
        id: create-packages
        run: |
          set -euo pipefail
          # Create SDK packages for distribution
          echo "📦 Creating SDK packages..."

          PACKAGES_CREATED=false

          # Create Go SDK package
          if [ -d "${{ inputs.output-path }}/go" ]; then
            cd "${{ inputs.output-path }}/go"
            tar -czf "../../gcommon-go-sdk.tar.gz" .
            zip -r "../../gcommon-go-sdk.zip" .
            cd ../..
            echo "✅ Go SDK package created"
            PACKAGES_CREATED=true
          fi

          # Create Python SDK package
          if [ -d "${{ inputs.output-path }}/python" ]; then
            cd "${{ inputs.output-path }}/python"
            tar -czf "../../gcommon-python-sdk.tar.gz" .
            zip -r "../../gcommon-python-sdk.zip" .
            cd ../..
            echo "✅ Python SDK package created"
            PACKAGES_CREATED=true
          fi

          # Create documentation package
          if [ -d "proto-docs" ]; then
            tar -czf gcommon-docs.tar.gz proto-docs/
            zip -r gcommon-docs.zip proto-docs/
            echo "✅ Documentation package created"
            PACKAGES_CREATED=true
          fi

          # Set output for later steps
          echo "packages-created=$PACKAGES_CREATED" >> "$GITHUB_OUTPUT"

          # List created packages
          if [ "$PACKAGES_CREATED" = true ]; then
            mapfile -t package_paths < <(find . -maxdepth 1 -type f \( -name "gcommon-*.tar.gz" -o -name "gcommon-*.zip" \) -print)
            if [ "${#package_paths[@]}" -gt 0 ]; then
              echo "Created packages:"
              printf '  %s\n' "${package_paths[@]}"
            else
              echo "No package files visible"
            fi
          else
            echo "No packages created"
          fi

      - name: Run post-generation processing
        if: ${{ !inputs.skip-post-processing }}
        run: |
          # Look for post-processing scripts
          SCRIPTS_FOUND=false

          if [ -f "scripts/post-buf-generate.py" ]; then
            echo "Running post-buf-generate.py..."
            python3 scripts/post-buf-generate.py
            SCRIPTS_FOUND=true
          fi

          if [ -f "scripts/setup-go-modules.py" ]; then
            echo "Running setup-go-modules.py..."
            python3 scripts/setup-go-modules.py
            SCRIPTS_FOUND=true
          fi

          if [ -f "scripts/setup-python-sdk.py" ]; then
            echo "Running setup-python-sdk.py..."
            python3 scripts/setup-python-sdk.py
            SCRIPTS_FOUND=true
          fi

          if [ "$SCRIPTS_FOUND" = false ]; then
            echo "No post-processing scripts found"
          fi

      - name: Generate documentation
        if: inputs.generate-docs
        run: |
          if [ -f "scripts/generate_proto_docs.py" ]; then
            echo "Generating protobuf documentation..."
            python3 scripts/generate_proto_docs.py
          else
            echo "No documentation generation script found"
          fi

      - name: Upload protobuf artifacts
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: protobuf-sdk-packages
          path: |
            gcommon-go-sdk.tar.gz
            gcommon-go-sdk.zip
            gcommon-python-sdk.tar.gz
            gcommon-python-sdk.zip
            gcommon-docs.tar.gz
            gcommon-docs.zip
            ${{ inputs.output-path }}/**/*.pb.go
            ${{ inputs.output-path }}/**/*_grpc.pb.go
            ${{ inputs.output-path }}/**/*.py
            ${{ inputs.output-path }}/**/*.pyi
            ${{ inputs.output-path }}/**/*.rs
            proto-docs/**/*.md
          if-no-files-found: ignore
          retention-days: 30

      - name: Check generated artifacts
        id: check-artifacts
        env:
          PROTOBUF_OUTPUT: ${{ inputs.output-path }}
        run: |
          python3 - <<'PY'
          from __future__ import annotations

          import os
          from pathlib import Path

          output_dir = Path(os.environ["PROTOBUF_OUTPUT"]).resolve()
          go_files = {p.resolve() for p in output_dir.rglob("*.pb.go")}
          go_files.update(p.resolve() for p in output_dir.rglob("*_grpc.pb.go"))

          python_files = {
              p.resolve()
              for pattern in ("*.py", "*.pyi")
              for p in output_dir.rglob(pattern)
              if "__pycache__" not in p.parts
          }

          docs_dir = Path("proto-docs")
          doc_files = {p.resolve() for p in docs_dir.rglob("*.md")} if docs_dir.exists() else set()

          output_path = Path(os.environ["GITHUB_OUTPUT"])
          with output_path.open("a", encoding="utf-8") as handle:
              handle.write(f"go-files-generated={len(go_files)}\n")
              handle.write(f"python-files-generated={len(python_files)}\n")
              handle.write(f"docs-generated={'true' if doc_files else 'false'}\n")
              handle.write(f"artifacts-available={'true' if go_files or python_files else 'false'}\n")

          print("=== Checking generated artifacts ===")
          print(f"Generated Go files: {len(go_files)}")
          print(f"Generated Python files: {len(python_files)}")
          print(f"Documentation generated: {'yes' if doc_files else 'no'}")

          if go_files or python_files:
              print("✅ Protobuf artifacts generated successfully")
          else:
              print("❌ No protobuf artifacts were generated")

          print("Sample generated files:")
          for path in list(sorted(go_files))[:3]:
              print(f"  {path}")
          for path in list(sorted(python_files))[:3]:
              print(f"  {path}")
          PY

  status-summary:
    name: Protobuf Generation Summary
    runs-on: ubuntu-latest
    needs: [load-config, generate-protobuf]
    if: always()
    steps:
      - name: Generate summary
        env:
          PROTOBUF_ENABLED: ${{ needs.load-config.outputs.protobuf-enabled }}
          CONFIG_LOADED: ${{ needs.load-config.outputs.config-loaded }}
          CONFIG_STATUS: ${{ needs.load-config.result }}
          GENERATE_STATUS: ${{ needs.generate-protobuf.result || 'skipped' }}
          GO_COUNT: ${{ needs.generate-protobuf.outputs.go-files-generated || 0 }}
          PYTHON_COUNT: ${{ needs.generate-protobuf.outputs.python-files-generated || 0 }}
          DOCS_GENERATED: ${{ needs.generate-protobuf.outputs.docs-generated || 'false' }}
          ARTIFACTS_AVAILABLE: ${{ needs.generate-protobuf.outputs.artifacts-available || 'false' }}
        run: |
          {
            printf '# 🔧 Protobuf Generation Results\n\n'

            if [ "$PROTOBUF_ENABLED" = "true" ]; then
              printf '**Protobuf Enabled:** ✅ Yes\n'
              printf '**Configuration Loaded:** %s\n\n' "$CONFIG_LOADED"
              printf '| Component | Status |\n'
              printf '|-----------|--------|\n'
              printf '| Configuration | %s |\n' "$CONFIG_STATUS"
              printf '| Code Generation | %s |\n\n' "$GENERATE_STATUS"

              if [ "$GENERATE_STATUS" = "success" ]; then
                printf '**Generated Files:**\n'
                printf '- Go files: %s\n' "$GO_COUNT"
                printf '- Python files: %s\n' "$PYTHON_COUNT"
                printf '- Documentation: %s\n' "$DOCS_GENERATED"
                printf '- Artifacts Available: %s\n' "$ARTIFACTS_AVAILABLE"
              fi
            else
              printf '**Protobuf Enabled:** ❌ No\n\n'
              printf 'Protobuf generation was skipped because it is not enabled in the repository configuration.\n'
            fi
          } >> "$GITHUB_STEP_SUMMARY"
