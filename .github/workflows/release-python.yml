# file: .github/workflows/release-python.yml
# version: 1.0.0
# guid: d4e5f6a7-b8c9-0d1e-2f3a-4b5c6d7e8f9a

name: Python Release

on:
  workflow_call:
    inputs:
      release_type:
        description: "Release type"
        required: false
        default: "auto"
        type: string
      prerelease:
        description: "Is this a prerelease?"
        required: false
        default: false
        type: boolean
      draft:
        description: "Create as draft?"
        required: false
        default: false
        type: boolean
    outputs:
      version:
        description: "The released version"
        value: ${{ jobs.release.outputs.version }}
      tag:
        description: "The release tag"
        value: ${{ jobs.release.outputs.tag }}

permissions:
  contents: write
  packages: write
  attestations: write
  id-token: write

env:
  PYTHON_VERSION: "3.12"

jobs:
  determine-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      changelog: ${{ steps.version.outputs.changelog }}
      should-release: ${{ steps.version.outputs.should-release }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js for semantic-release
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Create package.json for semantic-release
        run: |
          cat > package.json << EOF
          {
            "name": "python-project",
            "version": "0.0.0-development",
            "private": true,
            "devDependencies": {
              "@semantic-release/changelog": "^6.0.3",
              "@semantic-release/git": "^10.0.1",
              "@semantic-release/github": "^9.2.6",
              "@semantic-release/exec": "^6.0.3",
              "semantic-release": "^22.0.12",
              "conventional-changelog-conventionalcommits": "^7.0.2"
            }
          }
          EOF

      - name: Create semantic-release config for Python
        run: |
          cat > .releaserc.json << EOF
          {
            "branches": ["main"],
            "plugins": [
              [
                "@semantic-release/commit-analyzer",
                {
                  "preset": "conventionalcommits",
                  "releaseRules": [
                    {"type": "feat", "release": "minor"},
                    {"type": "fix", "release": "patch"},
                    {"type": "perf", "release": "patch"},
                    {"type": "revert", "release": "patch"},
                    {"type": "docs", "release": false},
                    {"type": "style", "release": false},
                    {"type": "chore", "release": false},
                    {"type": "refactor", "release": "patch"},
                    {"type": "test", "release": false},
                    {"type": "build", "release": false},
                    {"type": "ci", "release": false},
                    {"breaking": true, "release": "major"}
                  ]
                }
              ],
              [
                "@semantic-release/release-notes-generator",
                {
                  "preset": "conventionalcommits"
                }
              ],
              [
                "@semantic-release/exec",
                {
                  "prepareCmd": "python scripts/update_version.py \${nextRelease.version}"
                }
              ],
              [
                "@semantic-release/changelog",
                {
                  "changelogFile": "CHANGELOG.md"
                }
              ],
              [
                "@semantic-release/git",
                {
                  "assets": ["pyproject.toml", "setup.py", "__init__.py", "CHANGELOG.md"],
                  "message": "chore(release): \${nextRelease.version} [skip ci]\n\n\${nextRelease.notes}"
                }
              ],
              [
                "@semantic-release/github",
                {
                  "assets": [
                    "./dist/*.whl",
                    "./dist/*.tar.gz"
                  ]
                }
              ]
            ]
          }
          EOF

      - name: Install dependencies
        run: npm install

      - name: Determine next version
        id: version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MANUAL_RELEASE_TYPE: ${{ inputs.release_type }}
        run: |
          if [[ "$MANUAL_RELEASE_TYPE" != "auto" && "$MANUAL_RELEASE_TYPE" != "" ]]; then
            echo "Manual release type specified: $MANUAL_RELEASE_TYPE"
            # Try to get current version from pyproject.toml or setup.py
            if [[ -f "pyproject.toml" ]]; then
              CURRENT_VERSION=$(grep '^version = ' pyproject.toml | sed 's/version = "\(.*\)"/\1/' || echo "0.1.0")
            elif [[ -f "setup.py" ]]; then
              CURRENT_VERSION=$(grep 'version=' setup.py | sed 's/.*version="\([^"]*\)".*/\1/' || echo "0.1.0")
            else
              CURRENT_VERSION="0.1.0"
            fi

            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}

            case "$MANUAL_RELEASE_TYPE" in
              "major")
                NEW_VERSION="$((MAJOR + 1)).0.0"
                ;;
              "minor")
                NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
                ;;
              "patch")
                NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
                ;;
            esac

            echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "changelog=Manual $MANUAL_RELEASE_TYPE release" >> $GITHUB_OUTPUT
          else
            # Run semantic-release in dry-run mode to determine version
            npx semantic-release --dry-run > release_output.log 2>&1 || true

            if grep -q "The next release version is" release_output.log; then
              NEW_VERSION=$(grep "The next release version is" release_output.log | sed 's/.*The next release version is \([0-9.]*\).*/\1/')
              echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
              echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
              echo "should-release=true" >> $GITHUB_OUTPUT

              # Extract changelog
              CHANGELOG=$(npx semantic-release --dry-run 2>&1 | grep -A 100 "Release note for version" | tail -n +2 | head -n -1 || echo "Automated release")
              echo "changelog<<EOF" >> $GITHUB_OUTPUT
              echo "$CHANGELOG" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            else
              echo "No release needed based on conventional commits"
              echo "should-release=false" >> $GITHUB_OUTPUT
            fi
          fi

  build:
    name: Build Python Package
    runs-on: ubuntu-latest
    needs: determine-version
    if: needs.determine-version.outputs.should-release == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build twine setuptools wheel

      - name: Create version update script
        run: |
          mkdir -p scripts
          cat > scripts/update_version.py << 'EOF'
          #!/usr/bin/env python3
          import sys
          import re
          import os

          def update_version(new_version):
              # Update pyproject.toml
              if os.path.exists('pyproject.toml'):
                  with open('pyproject.toml', 'r') as f:
                      content = f.read()
                  content = re.sub(r'^version = ".*"', f'version = "{new_version}"', content, flags=re.MULTILINE)
                  with open('pyproject.toml', 'w') as f:
                      f.write(content)
                  print(f"Updated pyproject.toml version to {new_version}")

              # Update setup.py
              if os.path.exists('setup.py'):
                  with open('setup.py', 'r') as f:
                      content = f.read()
                  content = re.sub(r'version=["\'][^"\']*["\']', f'version="{new_version}"', content)
                  with open('setup.py', 'w') as f:
                      f.write(content)
                  print(f"Updated setup.py version to {new_version}")

              # Update __init__.py
              for root, dirs, files in os.walk('.'):
                  if '__init__.py' in files:
                      init_path = os.path.join(root, '__init__.py')
                      with open(init_path, 'r') as f:
                          content = f.read()
                      if '__version__' in content:
                          content = re.sub(r'__version__ = ["\'][^"\']*["\']', f'__version__ = "{new_version}"', content)
                          with open(init_path, 'w') as f:
                              f.write(content)
                          print(f"Updated {init_path} version to {new_version}")
                          break

          if __name__ == "__main__":
              if len(sys.argv) != 2:
                  print("Usage: python update_version.py <new_version>")
                  sys.exit(1)
              update_version(sys.argv[1])
          EOF
          chmod +x scripts/update_version.py

      - name: Update version in Python files
        run: |
          python scripts/update_version.py "${{ needs.determine-version.outputs.version }}"

      - name: Build package
        run: |
          python -m build

      - name: Check distribution
        run: |
          python -m twine check dist/*

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: python-package
          path: dist/*

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [determine-version, build]
    if: needs.determine-version.outputs.should-release == 'true'
    outputs:
      version: ${{ needs.determine-version.outputs.version }}
      tag: ${{ needs.determine-version.outputs.tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js for semantic-release
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./dist
          merge-multiple: true

      - name: List artifacts
        run: ls -la ./dist/

      - name: Create package.json for semantic-release
        run: |
          cat > package.json << EOF
          {
            "name": "python-project",
            "version": "0.0.0-development",
            "private": true,
            "devDependencies": {
              "@semantic-release/changelog": "^6.0.3",
              "@semantic-release/git": "^10.0.1",
              "@semantic-release/github": "^9.2.6",
              "@semantic-release/exec": "^6.0.3",
              "semantic-release": "^22.0.12",
              "conventional-changelog-conventionalcommits": "^7.0.2"
            }
          }
          EOF

      - name: Create version update script
        run: |
          mkdir -p scripts
          cat > scripts/update_version.py << 'EOF'
          #!/usr/bin/env python3
          import sys
          import re
          import os

          def update_version(new_version):
              # Update pyproject.toml
              if os.path.exists('pyproject.toml'):
                  with open('pyproject.toml', 'r') as f:
                      content = f.read()
                  content = re.sub(r'^version = ".*"', f'version = "{new_version}"', content, flags=re.MULTILINE)
                  with open('pyproject.toml', 'w') as f:
                      f.write(content)
                  print(f"Updated pyproject.toml version to {new_version}")

              # Update setup.py
              if os.path.exists('setup.py'):
                  with open('setup.py', 'r') as f:
                      content = f.read()
                  content = re.sub(r'version=["\'][^"\']*["\']', f'version="{new_version}"', content)
                  with open('setup.py', 'w') as f:
                      f.write(content)
                  print(f"Updated setup.py version to {new_version}")

              # Update __init__.py
              for root, dirs, files in os.walk('.'):
                  if '__init__.py' in files:
                      init_path = os.path.join(root, '__init__.py')
                      with open(init_path, 'r') as f:
                          content = f.read()
                      if '__version__' in content:
                          content = re.sub(r'__version__ = ["\'][^"\']*["\']', f'__version__ = "{new_version}"', content)
                          with open(init_path, 'w') as f:
                              f.write(content)
                          print(f"Updated {init_path} version to {new_version}")
                          break

          if __name__ == "__main__":
              if len(sys.argv) != 2:
                  print("Usage: python update_version.py <new_version>")
                  sys.exit(1)
              update_version(sys.argv[1])
          EOF
          chmod +x scripts/update_version.py

      - name: Create semantic-release config for Python
        run: |
          cat > .releaserc.json << EOF
          {
            "branches": ["main"],
            "plugins": [
              [
                "@semantic-release/commit-analyzer",
                {
                  "preset": "conventionalcommits",
                  "releaseRules": [
                    {"type": "feat", "release": "minor"},
                    {"type": "fix", "release": "patch"},
                    {"type": "perf", "release": "patch"},
                    {"type": "revert", "release": "patch"},
                    {"type": "docs", "release": false},
                    {"type": "style", "release": false},
                    {"type": "chore", "release": false},
                    {"type": "refactor", "release": "patch"},
                    {"type": "test", "release": false},
                    {"type": "build", "release": false},
                    {"type": "ci", "release": false},
                    {"breaking": true, "release": "major"}
                  ]
                }
              ],
              [
                "@semantic-release/release-notes-generator",
                {
                  "preset": "conventionalcommits"
                }
              ],
              [
                "@semantic-release/exec",
                {
                  "prepareCmd": "python scripts/update_version.py \${nextRelease.version}"
                }
              ],
              [
                "@semantic-release/changelog",
                {
                  "changelogFile": "CHANGELOG.md"
                }
              ],
              [
                "@semantic-release/git",
                {
                  "assets": ["pyproject.toml", "setup.py", "__init__.py", "CHANGELOG.md"],
                  "message": "chore(release): \${nextRelease.version} [skip ci]\n\n\${nextRelease.notes}"
                }
              ],
              [
                "@semantic-release/github",
                {
                  "assets": [
                    "./dist/*.whl",
                    "./dist/*.tar.gz"
                  ]
                }
              ]
            ]
          }
          EOF

      - name: Install dependencies
        run: npm install

      - name: Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [[ "${{ inputs.release_type }}" != "auto" && "${{ inputs.release_type }}" != "" ]]; then
            # Manual release - create GitHub release directly
            gh release create "${{ needs.determine-version.outputs.tag }}" \
              --title "Release ${{ needs.determine-version.outputs.version }}" \
              --notes "${{ needs.determine-version.outputs.changelog }}" \
              ${{ inputs.prerelease && '--prerelease' || '' }} \
              ${{ inputs.draft && '--draft' || '' }} \
              ./dist/*
          else
            # Use semantic-release for automated releases
            npx semantic-release
          fi

  publish-pypi:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [determine-version, build, release]
    if: needs.determine-version.outputs.should-release == 'true' && !inputs.prerelease
    environment: release
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: python-package
          path: dist/

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_API_TOKEN }}
          skip-existing: true
